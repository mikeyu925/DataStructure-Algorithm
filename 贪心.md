希望我练完`贪心算法`，不会变成一个`贪心的人`，而变成一个`能每次做出当前最优(局部最优)决定的人，从而达到我人生的最优态`，但是呢，并不是每个人的人生都是这样的，`即使你做出了当前最优的决策，也可能会走上人生的另一个岔路口`。 哦 好像后几句就挺像贪心思想的：**每一步都做出一个局部最优的选择，最终的结果就是全局最优。·但是只有一部分问题拥有这个性质。**

> 比如你面前放着 100 张人民币，你只能拿十张，怎么才能拿最多的面额？显然每次选择剩下钞票中面值最大的一张，最后你的选择一定是最优的。

最常见的贪心有两种。

> 摘取自 oi-wiki

- 「我们将 XXX 按照某某顺序排序，然后按某种顺序（例如从小到大）选择」
- 「我们每次都取 XXX 中最大/小的东西，并更新 XXX。」（有时「XXX 中最大/小的东西」可以优化，比如用优先队列维护）

> 二者的区别在于一种是离线的，先处理后选择；一种是在线的，边处理边选择。

> 个人经验：感觉好多贪心问题都需要先排序~，算不算是一个小规律呢？



#### 玩筹码

有 n 个筹码。第 i 个筹码的位置是 position[i] 。

我们需要把所有筹码移到同一个位置。在一步中，我们可以将第 i 个筹码的位置从 position[i] 改变为:

- position[i] + 2 或 position[i] - 2 ，此时 cost = 0
- position[i] + 1 或 position[i] - 1 ，此时 cost = 1

返回将所有筹码移动到同一位置上所需要的 最小代价 。

<img src="贪心.assets/chips_e1.jpg" alt="img" style="zoom:50%;" />

```
输入：position = [1,2,3]
输出：1
解释：第一步:将位置3的筹码移动到位置1，成本为0。
第二步:将位置2的筹码移动到位置1，成本= 1。
总成本是1。
```

可以把初始每一个偶数位置的「筹码」看作一个整体，每一个奇数位置的「筹码」看作一个整体。因为我们的目标是最后将全部的「筹码」移动到同一个位置，那么最后的位置只有两种情况：

- 移动到某一个偶数位置，此时的开销最小值就是初始奇数位置「筹码」的数量。

- 移动到某一个奇数位置，此时的开销最小值就是初始偶数位置「筹码」的数量。

那么这两种情况中的最小值就是最后将所有筹码移动到同一位置上所需要的最小代价。

```java
class Solution {
    public int minCostToMoveChips(int[] position) {
        int odd = 0,even = 0;
        int n = position.length;
        for(int i = 0;i < n;i++){
            if(position[i] % 2 == 0){
                even += 1;
            }else{
                odd += 1;
            }
        }
        return Math.min(odd,even);
    }
}
```







### 区间问题

区间问题感觉总是需要先排序...

#### 例题-区间选点

给定 N 个闭区间 $[a_i,b_i]$，请你在数轴上选择**尽量少**的点，使得每个区间内至少包含一个选出的点。

输出选择的点的**最小**数量。

位于区间端点上的点也算作区间内。

**输入格式**

第一行包含整数 N，表示区间数。

接下来 N 行，每行包含两个整数 $a_i,b_i$，表示一个区间的两个端点。

**输出格式**

输出一个整数，表示所需的点的最小数量。





#### 例题-区间合并









#### 例题-区间分组

给定 N 个闭区间 $[a_i,b_i]$，请你将这些区间分成若干组，使得每组内部的区间两两之间（包括端点）没有交集，并使得组数尽可能小。

输出最小组数。

**输入格式**

第一行包含整数 N，表示区间数。

接下来 N 行，每行包含两个整数 $a_i,b_i$，表示一个区间的两个端点。

**输出格式**

输出一个整数，表示最小组数。









#### 例题-区间覆盖

给定 N 个闭区间 $[a_i,b_i]$以及一个线段区间 $[s,t]$，请你选择尽量少的区间，将指定线段区间完全覆盖。

输出最少区间数，如果无法完全覆盖则输出 −1。

**输入格式**

第一行包含两个整数 s 和 t，表示给定线段区间的两个端点。

第二行包含整数 N，表示给定区间数。

接下来 N 行，每行包含两个整数 $a_i,b_i$，表示一个区间的两个端点。

**输出格式**

输出一个整数，表示所需最少区间数。

如果无解，则输出 −1。











### Huffman树

#### 例题-合并果子

在一个果园里，达达已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。

达达决定把所有的果子合成一堆。

每一次合并，达达可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。

可以看出，所有的果子经过 n−1次合并之后，就只剩下一堆了。

达达在合并果子时总共消耗的体力等于每次合并所耗体力之和。

因为还要花大力气把这些果子搬回家，所以达达在合并果子时要尽可能地节省体力。

假定每个果子重量都为 1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使达达耗费的体力最少，并输出这个最小的体力耗费值。

例如有 3 种果子，数目依次为 1，2，9。

可以先将 1、2堆合并，新堆数目为 3，耗费体力为 3。

接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 12，耗费体力为 12。

所以达达总共耗费体力=3+12=15。

可以证明 15为最小的体力耗费值。

**输入格式**

输入包括两行，第一行是一个整数 n，表示果子的种类数。

第二行包含 n 个整数，用空格分隔，第 i 个整数 $a_i$ 是第 i 种果子的数目。

**输出格式**

输出包括一行，这一行只包含一个整数，也就是最小的体力耗费值。

输入数据保证这个值小于 $2^31$。







### 排序不等式

#### 例题-排队打水

有 n 个人排队到 1 个水龙头处打水，第 i 个人装满水桶所需的时间是 $t_i$，请问如何安排他们的打水顺序才能使所有人的**等待时间之和**最小？

**输入格式**

第一行包含整数 n。

第二行包含 n 个整数，其中第 i 个整数表示第 i 个人装满水桶所花费的时间 $t_i$。

**输出格式**

输出一个整数，表示最小的等待时间之和。







### 绝对值不等式

#### 例题-货仓选址

在一条数轴上有 N 家商店，它们的坐标分别为 $A_1∼A_N$。

现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。

为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。

**输入格式**

第一行输入整数 N。

第二行 N 个整数 $A_1∼A_N$。

**输出格式**

输出一个整数，表示距离之和的最小值。







### 推公式

#### 例题-耍杂技的牛

农民约翰的 N 头奶牛（编号为 1..N）计划逃跑并加入马戏团，为此它们决定练习表演杂技。

奶牛们不是非常有创意，只提出了一个杂技表演：

叠罗汉，表演时，奶牛们站在彼此的身上，形成一个高高的垂直堆叠。

奶牛们正在试图找到自己在这个堆叠中应该所处的位置顺序。

这 N 头奶牛中的每一头都有着自己的重量 $W_i$ 以及自己的强壮程度 $S_i$。

一头牛支撑不住的可能性取决于它头上所有牛的总重量（不包括它自己）减去它的身体强壮程度的值，现在称该数值为风险值，风险值越大，这只牛撑不住的可能性越高。

您的任务是确定奶牛的排序，使得所有奶牛的风险值中的最大值尽可能的小。

**输入格式**

第一行输入整数 N，表示奶牛数量。

接下来 N 行，每行输入两个整数，表示牛的重量和强壮程度，第 i 行表示第 i 头牛的重量 $W_i$ 以及它的强壮程度 $S_i$。

**输出格式**

输出一个整数，表示最大风险值的最小可能值。

**题解**：

<img src="贪心.assets/image-20220426165303337.png" alt="image-20220426165303337" style="zoom:50%;" />