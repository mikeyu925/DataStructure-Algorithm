# 二分法

**二分法求方程的近似解**：

![1](二分法.assets/1.png)

```c
#define EPS 0.0000001
double f(int p,int q,double x){
    return p * x + q;
}
double bisection(int p,int q,double (*func)(int,int,double)){
    double left = -20,right = 20;
    double mid = (left + right) / 2;
    do{
        if(fabs(func(p,q,mid)) <= EPS){
            return mid;   
        }else if(f(p,q,mid) > EPS){
            if(p > 0) right = mid;
            else if(p < 0) left = mid;
        }
        else{
            if(p > 0) left = mid;
            else if(p < 0) right = mid;
        }
        mid = (left + right) / 2;
    }while(fabs(func(p,q,mid)) > EPS);
    return mid;    
}
```

## 二分查找基本框架

> 二分查找算法思想不难！难的是算法细节！

```c
bool  binSearch(int * arr,int n,int tar){
    int left = 0,right = n-1;
    //什么时候是 < 什么时候是 <=要考虑清除
    while(left <= right){
        //求中值mid优化 右移运算代替除法运算，运算更快，相减代替相加防止溢出 int mid = (left + right) / 2;
        int mid = left + ((right - left)>>1);
        //重点
        if(arr[mid] == tar) return true;
        else if(arr[mid] > tar) right = mid - 1;
        else left = mid + 1;
    }
    return false;
}
```

## 二分查找变形

### 查找第一个值等于给定值的元素

其实这只是对基本二分查找的变形：

```cpp
//**查找第一个值等于给定值的元素**
int bsearchFirst(vector<int> & nums,int val){
    int n = nums.size();    
    int left = 0;
    int right = n - 1;
    while (left <= right)
    {
        int mid = left + ((right - left)>>1);
        if (nums[mid] < val){
            left = mid + 1;
        }else if (nums[mid] > val){
            right = mid - 1;
        }else {
            if (mid == 0 || nums[mid - 1] != val)
                return mid;
            else
                right = mid - 1;
        }
    }
    return -1;
}
```

> 如果我们查找的是任意一个值等于给定值的元素，当 `nums[mid]`等于要查找的值时，`nums[mid]`就是我们要找的元素。但是，如果我们求解的是第一个值等于给定值的元素，当 `nums[mid]`等于要查找的值时，我们就需要确认一下这个 `nums[mid]`是不是第一个值等于给定值的元素。

>  我们重点看`if (mid == 0 || nums[mid - 1] != val)`行代码。如果 `mid` 等于 0，那这个元素已经是数组的第一个元素，那它肯定是我们要找的；如果 `mid` 不等于 0，但 `nums[mid]`的前一个元素 `nums[mid-1]`不等于 `value`，那也说明 `nums[mid]`就是我们要找的第一个值等于给定值的元素。

> 如果经过检查之后发现 `nums[mid]`前面的一个元素 `nums[mid-1]`也等于 `value`，那说明此时的 `nums[mid]`肯定不是我们要查找的第一个值等于给定值的元素。那我们就更新 `high=mid-1`，因为要找的元素肯定出现在`[low, mid-1]`之间。

### 查找最后一个值等于给定值的元素

同样的，查找最后一个值等于给定值的元素也和上述思路相同。

```cpp
//**查找最后一个值等于给定值的元素**
int bsearchLast(vector<int> & nums,int val){
    int n = nums.size();
    int left = 0;
    int right = n - 1;
    while (left <= right)
    {
        int mid = left+((right - left) >> 1);
        if (nums[mid] < val){
            left = mid + 1;
        }else if (nums[mid] > val){
            right = mid - 1;
        }else{
            if (mid == n - 1 || nums[mid + 1] != val){
                return mid;
            }else{
                left = mid + 1;
            }
        }
    }
    return -1;
}
```

### 查找第一个大于等于给定值的元素

```cpp
//**查找第一个大于等于给定值的元素**
int bsearchOverFirst(vector<int> &nums,int val){
    int n = nums.size();
    int left = 0;
    int right = n - 1;
    while (left <= right){
        int mid = left + ((right - left)>>1);
        if (nums[mid] >= val){
            if (mid == 0 || (nums[mid - 1] < val)){
                return mid;    
            }
            right = mid - 1;
        }else{
            left = mid + 1;
        }
    }
    return -1;
}
```

### 查找最后一个小于等于给定值的元素

```cpp
//**查找最后一个小于等于给定值的元素**
int bsearchOverLast(vector<int> & nums,int val){
    int n = nums.size();
    int left = 0;
    int right = n - 1;
    while (left <= right){
        int mid = left + ((right - left)>>1);
        if (nums[mid] <= val){
            if (mid == n-1 || nums[mid + 1] > val){
                return mid;
            }
            left = mid + 1;
        }else{
            right = mid - 1;
        }
    }
    return -1;
}
```

## 二分"结果"题型

要点：

- 是否单调？

- 上下界范围？
- “分”什么？

为什么叫二分结果？因为**分的是结果**

### 示例——**原木切割**

```
某林业局现在 N 根原木，长度分别为 Xi，为了便于运输，需要将他们切割成长度相等的 M 根小段原木（只能切割成整数长度，可以有剩余），小段原木的长度越大越好，现求小段原木的最大长度。例如，有 3 根原木长度分别为 6,15,22，现在需要切成 8 段，那么最大长度为 5。
输入
​ 第一行两个整数 N,M。（1≤N≤100,000，1≤M≤100,000,000）
​ 接下来 N 行，每行一个数，表示原木的长度 Xi。（1≤Xi≤100,000,000）
输出
​ 输出小段原木的最大长度， 保证可以切出 M 段。
```

<img src="F:\Typora\Picture\leetcode\原木切割题解.jpg" alt="原木切割题解" style="zoom: 50%;" />

```cpp
//程序代码——原木切割
#include<iostream>
#include<algorithm>
#include<stdio.h>
using namespace std;
int n,m,num[100005],r,l = 1;
//根据切割距离x求取段数t
int func(int x){
    int t = 0;
    for(int i = 1;i <= n;i++){
        t += num[i] / x;
    }
    return t;
}
//二分查找
int bs(void){
    while(l != r){
        int mid = ((long long)l + r + 1 ) /2;//防止出现死循环
        int t = func(mid);
        if(t >= m){
            l = mid;
        }else{
            r = mid - 1;
        }
    }
    return r; //此时r == l，返回哪个都行
}
int main(){
    scanf("%d %d",&n,&m);
    for(int i = 1;i <= n;i++){
        scanf("%d",&num[i]);
        r = max(r,num[i]); //更新最右边界
    }
    printf("%d\n",bs());
    return 0;
}
```

```
小密招：
左绿右红
	mid = (l + r + 1) / 2;
	l = mid;
	r = mid - 1;
左红右绿
	mid = (l + r) / 2
	r = mid;
	l = mid + 1;
```



### 示例——**切绳子**

```
 有 N 条绳子，它们的长度分别为 Li。如果从它们中切割出 K 条长度相同的绳子，这 K 条绳子每条最长能有多长？答案保留到小数点后 2 位(直接舍掉 2 位后的小数)。
输入
​ 第一行两个整数 N 和 K，接下来 N 行，描述了每条绳子的长度 Li。
输出
​ 切割后每条绳子的最大长度，保证答案大于零。
```

注意：当数据类型为浮点型时，while判断内容变了！

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n,k;
double num[10005],maxr;
//切割长度为m时可以切t条绳子
int func(double m){
    int t = 0;
    for(int i = 0;i < n;i++){
        t += num[i] / m;//浮点型转int整形，直接去掉了小数点后数字
    }
    return t;
}
//二分答案
double bs(void){
    double l = 0,r = maxr;
    while(r - l > 0.0001){
        double mid = (l + r)/2;//虽然为左绿有红，但因为判断改变，不用+1
        int t = func(mid);
        if(t >= k){
            l = mid;//注意 不需要+1
        }else{
            r = mid;//注意 不需要-1
        }
    }
    return r;
}
int main(){
    scanf("%d %d",&n,&k);
    for(int i = 0;i < n;i++){
        scanf("%lf",&num[i]);
        maxr = max(maxr,num[i]);//更新右边界
    }
    printf("%.2f\n",bs() - 0.005f);
    return 0;
}
```

## 伪有序二分

> 这个==伪有序==二分是我自己起的名字，可能不太形象，但是我们通常会遇到一些题型比如【畸形的有序】，依然可以采用二分方法解决

### 在旋转排序数组中搜索

```
整数数组 nums 按升序排列，数组中的值 互不相同 。

在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。
例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。

给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。
```

```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

> 在前面的二分题目中，重点就是找到目标值和当前`num[mid]`的==相对位置==，以此来判断向左还是向右搜索，此题的重点也是这样，只是条件可能复杂些。

![旋转排序数组中搜索](二分法.assets/旋转排序数组中搜索.jpg)

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = nums.size();
        int left = 0,right = n - 1;
        while(left <= right){
            int mid = left + ((right - left) >> 1);
            //找到答案，直接返回
            if(target == nums[mid]) return mid;
            if(nums[mid] >= nums[0]){//nums[mid]在左半区间
                //开始判断target在哪
                if(target < nums[0])//目标值在右半区间
                    left = mid + 1;
                else{//目标值在左半区间，此时要判断和nums[mid]的相对位置
                    if(target < nums[mid]) right = mid - 1;
                    else left = mid + 1;
                }
            }else{//nums[mid]在右半区间
                if(target >= nums[0])//目标值在左半区间
                    right = mid - 1;
                else{//目标值在右半区间，要判断和nums[mid]的相对位置
                    if(target < nums[mid]) right = mid - 1;
                    else left = mid + 1;
                }
            }
        }
        return -1;
    }
};
```

### 寻找旋转排序数组中的最小值

```
已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：
若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]
```

> 给你一个元素值 `互不相同` 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

```
输入：nums = [3,4,5,1,2]
输出：1
```

> 本题和上一题"在旋转排序数组中搜索"很相似，都是伪有序的搜索，在搜素过程中需要判断当前处于的区域，并要清楚查找结束条件

<img src="F:\Typora\Picture\leetcode\寻找旋转排序数组中的最小值.jpg" alt="寻找旋转排序数组中的最小值" style="zoom: 67%;" />

```cpp
class Solution {
public:
    int findMin(vector<int> &nums){
        int n = nums.size();
        //如果是单调递增的，直接返回第一个值
        if(nums[0] < nums[n-1]) return nums[0];
        int left = 0,right = n-1;
        while(left < right){
            int mid = left + ((right - left) >> 1);
            //mid在左半区域，一定不是最小值
            if(nums[mid] >= nums[0]){
                left = mid + 1;
            }else{//在右半区域
                if(mid > 0 && nums[mid] < nums[mid-1]) return nums[mid];
                right = mid - 1;
            }
        }
        return nums[left];
    }
};
```

### 寻找旋转排序数组中的最小值II

```
已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：
```

> 给你一个可能存在 `重复` 元素值的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

> 当存在重复元素后，就不好明确区分是在哪个区间了，但是我们依旧要缩小查找范围，如何缩小？这便是要解决的重要问题之一

![寻找旋转排序数组中的最小值II](二分法.assets/寻找旋转排序数组中的最小值II.jpg)

```cpp
class Solution {
public:
    int findMin(vector<int> &nums){
        int n = nums.size();
        int left = 0,right = n-1;
        while (left < right){
            int mid = left + ((right - left) >> 1);
            //如果在右半部分区域
            if (nums[mid] < nums[right]){
                //注意下面的两种判断方法都可以，但是要清楚为什么要这样
                #if 0    
                    if(mid > 0 && nums[mid] < nums[mid-1]) return nums[mid];
                    right = mid - 1;
                #else
                    right = mid;
                #endif
            }else if (nums[mid] > nums[right])//左半部分区域
            {
                left = mid + 1;
            }else{//将nums[right]排除在下次查找区域
                right--;
            }
        }
        return nums[left];
    }
};
```



