## 线段树

线段树将每个长度不为 1 的区间划分成左右两个区间递归求解，把整个线段划分为一个树形结构，通过合并左右两区间信息来求得该区间的信息。这种数据结构可以方便的解决多种范围查询问题，比如在对数时间内**从数组中找到最小值、最大值、总和、最大公约数、最小公倍数**等。

类似如下图所示：

![image.png](线段树.assets/1647760524-xRniLE-image.png)

同时，每个结点可以携带一些信息，比如下图所示：

设线段树的根节点编号为 1，用数组 d 来保存我们的线段树， $d_i$用来保存线段树上编号为 i 的节点的值（这里每个节点所维护的值就是这个节点所表示的区间总和）

<img src="线段树.assets/segt1.svg" alt="img" style="zoom:50%;" />

图中每个节点中用红色字体标明的区间，表示该节点管辖的 a 数组上的位置区间。如 $d_1$所管辖的区间就是 $[1,5],\text{即}(a_1,a_2,...,a_5)$，即 $d_1$所保存的值是$a_1+a_2+...+a_5$ ， 即$d_1 = 60$ 。

>  $d_i$的左儿子节点表示的是区间$[s,(s+t)/2]$ ， $d_i$的右儿子表示的是区间$[(s+t)/2+1,t]$ 。
>
> 如果索引 i 处的元素不是一个叶节点，那么其左子节点和右子节点分别存储在索引为 2i 和 2i+1的元素处。

实现时，我们考虑**递归建树**。设当前的根节点为 p ，如果根节点管辖的区间长度已经是 1 ，则可以直接根据 a 数组上相应位置的值初始化该节点。否则我们将该区间从中点处分割为两个子区间，分别进入左右子节点递归建树，最后合并两个子节点的信息。





### 示例-区域和检索 - 数组可修改 (区间和问题)

> 题目来源：Leetcode 307
>
> 标签：线段树

给你一个数组 nums ，请你完成两类查询。

其中一类查询要求 更新 数组 nums 下标对应的值
另一类查询要求返回数组 nums 中索引 left 和索引 right 之间（ 包含 ）的nums元素的 和 ，其中 left <= right
实现 NumArray 类：

- NumArray(int[] nums) 用整数数组 nums 初始化对象
- void update(int index, int val) 将 nums[index] 的值 更新 为 val
- int sumRange(int left, int right) 返回数组 nums 中索引 left 和索引 right 之间（ 包含 ）的nums元素的 和 （即，nums[left] + nums[left + 1], ..., nums[right]）

线段树可以分为以下三个步骤：

1. 从给定数组构建线段树的预处理步骤。
2. 修改元素时更新线段树。
3. 使用线段树进行区域和检索

**构建线段树**：

从上面我们已经知道，如果某个节点 p 包含范围 $[i\ldots j]$的和，那么其左、右子节点分别包含范围 $[i \ldots \frac{i + j}{2}]$ 和$[\frac{i + j}{2} + 1, j]$上的和。

```java
class NumArray {
    int [] tree; // 线段树
    int n;
    public NumArray(int[] nums) {
        if (nums.length > 0){
            n = nums.length;
            tree = new int[n * 2];
            buildTree(nums); // 建树
        }
    }
    // 创建树的过程可以参考本文第一张图片
    private void buildTree(int [] nums){
        for (int i = n,j = 0;i < 2 *n;i++,j++){ // (n个元素)
            tree[i] = nums[j];
        }
        for (int i = n-1;i > 0;i--){ // i : n-1 ~ 1(n-1个元素)
            tree[i] = tree[i*2] + tree[i*2+1];
        }
    }
    // 将下标为index的元素更新为val 
    public void update(int index, int val) {
        index += n; // 找到对应到线段树数组tree中的下标
        tree[index] = val; // 修改元素值
        while (index > 0){
            int left = index;
            int right = index;
            // left的下标一定是偶数，right的下标一定是奇数，并且 left < right
            if (index % 2 == 0){
                right = index + 1;
            }else{
                left = index - 1;
            }
            // 修改父节点对应的元素和
            tree[index / 2] = tree[left] + tree[right];
            index /= 2; // 自下而上递归（循环代替递归）
        }
    }

    public int sumRange(int left, int right) {
        // 起始位置是单个位置
        left += n;
        right += n;
        int sum = 0;
        while (left <= right){
            // 如果 left 对应的是奇数，那么说明不是完整的，即只包含了区间的一部分
            if ((left % 2) == 1){
                sum += tree[left];
                left += 1;
            }
            // 如果 right 对应的是偶数，和上述原理一样
            if ((right % 2) == 0){
                sum += tree[right];
                right -= 1;
            }
            // 向上移动一层
            left /= 2; 
            right /= 2;
        }
        return sum;
    }
}
```

<img src="线段树.assets/xianduanshu .jpg" alt="xianduanshu " style="zoom:50%;" />

