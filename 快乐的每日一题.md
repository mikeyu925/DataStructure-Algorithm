之前的每日一题没有记录！从今天开始`2022.1.1`！新的一年一切顺利！父母健康！学业顺利！

#### 20220101：将一维数组变成二维数组

> 题目来源：LeetCode 剑指 Offer 2022

给你一个下标从 0 开始的一维整数数组 original 和两个整数 m 和  n 。你需要使用 original 中 所有 元素创建一个 m 行 n 列的二维数组。

original 中下标从 0 到 n - 1 （都 包含 ）的元素构成二维数组的第一行，下标从 n 到 2 * n - 1 （都 包含 ）的元素构成二维数组的第二行，依此类推。

请你根据上述过程返回一个 m x n 的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组

```java
class Solution {
    public int[][] construct2DArray(int[] original, int m, int n) {
        int cnt = original.length;
        if (cnt != m * n) return new int[0][0];
        int [][] ans = new int[m][n];
        int k = 0;
        for (int i = 0;i < m;i++){
            for (int j = 0;j < n;j++){
                ans[i][j] = original[k++];
            }
        }
        return ans;
    }
}
```

> 2022年第一天哈哈哈LeetCode官方也是用心了！❤

> 希望看到这个文档的人都能够顺顺利利！



#### 20220203：和为 K 的最少斐波那契数字数目

> 题目来源：LeetCode 1414.
>
> 标签： 贪心

给你数字 k ，请你返回和为 k 的斐波那契数字的最少数目，其中，每个斐波那契数字都可以被使用多次。

斐波那契数字定义为：

- F1 = 1
- F2 = 1
- Fn = Fn-1 + Fn-2 ， 其中 n > 2 。

数据保证对于给定的 k ，一定能找到可行解。

**题目解析**：

首先找到所有不超过 k 的斐波那契数字，然后每次贪心地选取不超过 k 的最大斐波那契数字，将 k 减去该斐波那契数字，重复该操作直到 k 变为 0，此时选取的斐波那契数字满足和为 k 且数目最少。

```java
class Solution {
    public int findMinFibonacciNumbers(int k) {
        List<Integer> dp = new ArrayList<>();
        dp.add(1);
        dp.add(1);
        int tmp = 2;
        while (tmp <= k){
            int last = dp.get(dp.size()-1);
            dp.add(tmp);
            tmp += last;
        }
        int ans = 0;
        int n = dp.size()-1;
        while (k != 0){
            if (k < dp.get(n)){
                n -= 1;
                continue;
            }
            k -= dp.get(n);
            ans += 1;
        }
        return ans;
    }
}
```

#### 20220204：可以形成最大正方形的矩形数目

> 题目来源：LeetCode 1725.
>
> 标签： 模拟、数组

给你一个数组 rectangles ，其中$ rectangles[i] = [l_i, w_i]$ 表示第 i 个矩形的长度为$ l_i $、宽度为 $w_i$ 。

如果存在 k 同时满足$ k <= l_i$ 和 $k <= w_i$ ，就可以将第 i 个矩形切成边长为 k 的正方形。例如，矩形 [4,6] 可以切成边长最大为 4 的正方形。

设 maxLen 为可以从矩形数组 rectangles 切分得到的 最大正方形 的边长。

请你统计有多少个矩形能够切出边长为 maxLen 的正方形，并返回矩形 数目 。

```java
class Solution {
    public int countGoodRectangles(int[][] rectangles) {
        int maxLen = 0;
        int cnt = 0;
        for (int i = 0;i < rectangles.length;i++){
            int len = Math.min(rectangles[i][0],rectangles[i][1]);
            if (maxLen == len){
                cnt += 1;
            }else if (maxLen < len){
                maxLen = len;
                cnt = 1;
            }
        }
        return cnt;
    }
}
```



#### 20220205：黄金矿工

> 题目来源：LeetCode 1219
>
> 标签： 深度优先搜索

你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 `m * n` 的网格 `grid` 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 `0`。

为了使收益最大化，矿工需要按以下规则来开采黄金：

- 每当矿工进入一个单元，就会收集该单元格中的所有黄金。
- 矿工每次可以从当前位置向上下左右四个方向走。
- 每个单元格只能被开采（进入）一次。
- **不得开采**（进入）黄金数目为 `0` 的单元格。
- 矿工可以从网格中 **任意一个** 有黄金的单元格出发或者是停止。



```java
class Solution {
    int maxFrofit = 0;
    int dirs[][] = new int[][]{{-1,0},{1,0},{0,1},{0,-1}};
    int n,m;
    public void dfs(int x,int y,int[][] grid,int nowval){
        if(grid[x][y] == 0) return;
        nowval += grid[x][y];
        if(nowval > maxFrofit) maxFrofit = nowval;
        int tmp = grid[x][y];
        grid[x][y] = 0;
        for(int i = 0;i < 4;i++){
            int nx = x + dirs[i][0];
            int ny = y + dirs[i][1];
            if(nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
            dfs(nx,ny,grid,nowval);
        }
        grid[x][y] = tmp;
        
    }
    public int getMaximumGold(int[][] grid) {
        n = grid.length;
        m = grid[0].length;
        for(int i = 0;i < grid.length;i++){
            for(int j = 0;j <grid[i].length;j++){
                dfs(i,j,grid,0);
            }
        }
        return maxFrofit;
    }
}
```





#### 20220206：唯一元素的和

> 题目来源：LeetCode 1748
>
> 标签： 哈希表

给你一个整数数组 `nums` 。数组中唯一元素是那些只出现 **恰好一次** 的元素。

请你返回 `nums` 中唯一元素的 **和** 。

```java
class Solution {
    public int sumOfUnique(int[] nums) {
        Map<Integer,Integer> m = new HashMap<>();
        for (int i = 0;i < nums.length;i++){
            m.put(nums[i],m.getOrDefault(nums[i],0)+1);
        }
        int sum = 0;
        for (int i = 0;i < nums.length;i++){
            if (m.get(nums[i]) == 1){
                sum += nums[i];
            }
        }
        return sum;
    }
}
```



#### 20220207：最长快乐字符串

> 题目来源：LeetCode 1405
>
> 标签： 贪心、优先级队列

如果字符串中不含有任何 `'aaa'`，`'bbb'` 或 `'ccc'` 这样的字符串作为子串，那么该字符串就是一个「快乐字符串」。

给你三个整数 `a`，`b` ，`c`，请你返回 **任意一个** 满足下列全部条件的字符串 `s`：

- `s` 是一个尽可能长的快乐字符串。
- `s` 中 **最多** 有`a` 个字母 `'a'`、`b` 个字母 `'b'`、`c` 个字母 `'c'` 。
- `s `中只含有 `'a'`、`'b'` 、`'c'` 三种字母。

如果不存在这样的字符串 `s` ，请返回一个空字符串 `""`。

**题目解析**：

**回溯**：

一开始想到的是回溯，但是超时了...然后换方法= =!  但是代码也贴上把...

> 逐个添加字母，添加前判断当前字母能否被加入，如果都不能则已经找到最长快乐字符串。

```java
class Solution {
    StringBuilder sb = new StringBuilder();
    int maxlen = Integer.MIN_VALUE;
    String ans = null;
    public void dfs(int a,int b,int c,boolean finsh){
        if ((a == 0 && b == 0 && c ==0) || finsh){
            if (sb.length() > maxlen){
                maxlen = sb.length();
                ans = sb.toString();
            }
            return ;
        }
        int nowlen = sb.length();
        boolean ok = true;
        if (a > 0 && (sb.length() < 2 || (sb.length() >= 2 && !(sb.charAt(nowlen-1) == sb.charAt(nowlen-2) && sb.charAt(nowlen-1) == 'a')))){
            ok = false;
            sb.append('a');
            dfs(a-1,b,c,false);
            sb.deleteCharAt(sb.length()-1);
        }
        if (b > 0 && (sb.length() < 2 || (sb.length() >= 2 && !(sb.charAt(nowlen-1) == sb.charAt(nowlen-2) && sb.charAt(nowlen-1) == 'b')))){
            ok = false;
            sb.append('b');
            dfs(a,b-1,c,false);
            sb.deleteCharAt(sb.length()-1);
        }
        if (c > 0 && (sb.length() < 2 || (sb.length() >= 2 && !(sb.charAt(nowlen-1) == sb.charAt(nowlen-2) && sb.charAt(nowlen-1) == 'c')))){
            ok = false;
            sb.append('c');
            dfs(a,b,c-1,false);
            sb.deleteCharAt(sb.length()-1);
        }
        if (ok){
            dfs(a,b,c,true);
        }
    }
    public String longestDiverseString(int a, int b, int c) {
        dfs(a,b,c,false);
        return ans;
    }
}
```

**贪心策略**：

1. 尽可能优先使用当前数量最多的字母

   > 因为最后同一种字母剩余的越多，越容易出现字母连续相同的情况

2. 从数量最多的字母开始尝试，如果发现加入当前字母会导致`三个连续相同的字母`，则跳过当前字母，选择数量次多的其他字母

3. 如果所有的字母都无法添加，则已经找到了最长的快乐字符串

```java
class Pair{
    int cnt;
    char ch;
    Pair(int cnt,char ch){
        this.cnt = cnt;
        this.ch = ch;
    }
}

public class Solution {
    public String longestDiverseString(int a, int b, int c) {
        StringBuilder sb = new StringBuilder();
        Queue<Pair> pq = new PriorityQueue<>(new Comparator<Pair>() {
            @Override
            public int compare(Pair o1, Pair o2) {
                return o2.cnt - o1.cnt;
            }
        });
        pq.offer(new Pair(a,'a'));
        pq.offer(new Pair(b,'b'));
        pq.offer(new Pair(c,'c'));
        String ans = "";
        while (!pq.isEmpty()){
            Pair head = pq.poll();  // 弹出当前栈顶元素
            if (head.cnt == 0){  //如果栈顶元素的cnt==0说明后面的都是0，直接break
                ans = sb.toString();
                break;
            }
            int n = sb.length();
            if (n >= 2 && sb.charAt(n-1) == sb.charAt(n-2) && sb.charAt(n-1) == head.ch){ //如果当前元素再添加就会连续重复3次，则选择次大的
                if (!pq.isEmpty() && pq.peek().cnt > 0){
                    Pair tmp = pq.poll();
                    sb.append(tmp.ch);
                    tmp.cnt -= 1;
                    pq.offer(tmp);
                    pq.offer(head);
                    continue;
                }else{
                    ans = sb.toString();
                    break;
                }
            }
            sb.append(head.ch);
            head.cnt -= 1;
            pq.offer(head);
        }
        return ans;
    }
}
```



#### 20220208：网格照明

> 题目来源：LeetCode 1001
>
> 标签： 哈希表

在大小为 `n x n` 的网格 `grid` 上，每个单元格都有一盏灯，最初灯都处于 **关闭** 状态。

给你一个由灯的位置组成的二维数组 `lamps` ，其中 `lamps[i] = [rowi, coli]` 表示 **打开** 位于 `grid[rowi][coli]` 的灯。即便同一盏灯可能在 `lamps` 中多次列出，不会影响这盏灯处于 **打开** 状态。

当一盏灯处于打开状态，它将会照亮 **自身所在单元格** 以及同一 **行** 、同一 **列** 和两条 **对角线** 上的 **所有其他单元格** 。

另给你一个二维数组 `queries` ，其中 `queries[j] = [rowj, colj]` 。对于第 `j` 个查询，如果单元格 `[rowj, colj]` 是被照亮的，则查询结果为 `1` ，否则为 `0` 。在第 `j` 次查询之后 [按照查询的顺序] ，**关闭** 位于单元格 `grid[rowj][colj]` 上及相邻 8 个方向上（与单元格 `grid[rowi][coli]` 共享角或边）的任何灯。

返回一个整数数组 `ans` 作为答案， `ans[j]` 应等于第 `j` 次查询 `queries[j]` 的结果，`1` 表示照亮，`0` 表示未照亮。

![img](快乐的每日一题.assets/illu_1.jpg)

```
输入：n = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,0]]
输出：[1,0]
```

<img src="快乐的每日一题.assets/illu_step1.jpg" alt="img" style="zoom:67%;" />

<img src="快乐的每日一题.assets/illu_step2.jpg" alt="img" style="zoom:67%;" />

```java
    public int[] gridIllumination(int n, int[][] lamps, int[][] queries) {
        Map<Integer,Integer> rows = new HashMap<>();
        Map<Integer,Integer> cols = new HashMap<>();
        Map<Integer,Integer> diagonal = new HashMap<>();  //斜着的直线可以看成坐标系中的一个直线方程
        Map<Integer,Integer> backdiagonal = new HashMap<>(); 
        Set<Integer> points = new HashSet<>();
        for (int [] lamp : lamps){
            // 计算坐标对应的 val
            int val = lamp[0] * n + lamp[1];
            if (points.contains(val)) continue; //如果之前当前位置的灯已经打开，跳过
            points.add(val);  //加入当前打开的灯
            //设置该点对应的行、列、正负对角线是被照亮的
            rows.put(lamp[0],rows.getOrDefault(lamp[0],0) + 1);
            cols.put(lamp[1],cols.getOrDefault(lamp[1],0) + 1);
            diagonal.put(lamp[0]-lamp[1],diagonal.getOrDefault(lamp[0]-lamp[1],0) + 1);
            backdiagonal.put(lamp[0]+lamp[1],backdiagonal.getOrDefault(lamp[0]+lamp[1],0) + 1);
        }
        int [] ans = new int[queries.length];
        for (int i = 0;i < queries.length;i++){
            int r = queries[i][0],c = queries[i][1];
            //如果 当前点所在位置的 行 、 列 、正负对角线 有一个被照亮，设置对应答案为1
            if (rows.getOrDefault(r,0) > 0){
                ans[i] = 1;
            }else if (cols.getOrDefault(c,0) > 0){
                ans[i] = 1;
            }else if (diagonal.getOrDefault(r-c,0) > 0){
                ans[i] = 1;
            }else if (backdiagonal.getOrDefault(r+c,0) > 0){
                ans[i] = 1;
            }
            //消除相邻中灯泡被打开的灯，并关闭所对应的行列、对角线
            for (int x = r - 1; x <= r+1;x++){
                for (int y = c - 1; y <= c + 1;y++){
                    if (x < 0 || y < 0 || x >= n || y >= n) continue;  //超过范围
                    int val = x * n + y;
                    //是否被打开
                    if (points.contains(val)){
                        //关闭该灯
                        points.remove(val);
                        //关闭行、列、正负对角线 所对应的光路
                        rows.put(x,rows.getOrDefault(x,0) - 1);
                        cols.put(y,cols.getOrDefault(y,0) - 1);
                        diagonal.put(x-y,diagonal.getOrDefault(x-y,0) - 1);
                        backdiagonal.put(x+y,backdiagonal.getOrDefault(x+y,0) - 1);
                    }
                }
            }
        }
        return ans;
    }
```

