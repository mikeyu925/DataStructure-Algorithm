之前的每日一题没有记录！从今天开始`2022.1.1`！新的一年一切顺利！父母健康！学业顺利！

#### 20220101：将一维数组变成二维数组

> 题目来源：LeetCode 剑指 Offer 2022

给你一个下标从 0 开始的一维整数数组 original 和两个整数 m 和  n 。你需要使用 original 中 所有 元素创建一个 m 行 n 列的二维数组。

original 中下标从 0 到 n - 1 （都 包含 ）的元素构成二维数组的第一行，下标从 n 到 2 * n - 1 （都 包含 ）的元素构成二维数组的第二行，依此类推。

请你根据上述过程返回一个 m x n 的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组

```java
class Solution {
    public int[][] construct2DArray(int[] original, int m, int n) {
        int cnt = original.length;
        if (cnt != m * n) return new int[0][0];
        int [][] ans = new int[m][n];
        int k = 0;
        for (int i = 0;i < m;i++){
            for (int j = 0;j < n;j++){
                ans[i][j] = original[k++];
            }
        }
        return ans;
    }
}
```

> 2022年第一天哈哈哈LeetCode官方也是用心了！❤

> 希望看到这个文档的人都能够顺顺利利！



#### 20220203：和为 K 的最少斐波那契数字数目

> 题目来源：LeetCode 1414.
>
> 标签： 贪心

给你数字 k ，请你返回和为 k 的斐波那契数字的最少数目，其中，每个斐波那契数字都可以被使用多次。

斐波那契数字定义为：

- F1 = 1
- F2 = 1
- Fn = Fn-1 + Fn-2 ， 其中 n > 2 。

数据保证对于给定的 k ，一定能找到可行解。

**题目解析**：

首先找到所有不超过 k 的斐波那契数字，然后每次贪心地选取不超过 k 的最大斐波那契数字，将 k 减去该斐波那契数字，重复该操作直到 k 变为 0，此时选取的斐波那契数字满足和为 k 且数目最少。

```java
class Solution {
    public int findMinFibonacciNumbers(int k) {
        List<Integer> dp = new ArrayList<>();
        dp.add(1);
        dp.add(1);
        int tmp = 2;
        while (tmp <= k){
            int last = dp.get(dp.size()-1);
            dp.add(tmp);
            tmp += last;
        }
        int ans = 0;
        int n = dp.size()-1;
        while (k != 0){
            if (k < dp.get(n)){
                n -= 1;
                continue;
            }
            k -= dp.get(n);
            ans += 1;
        }
        return ans;
    }
}
```

#### 20220204：可以形成最大正方形的矩形数目

> 题目来源：LeetCode 1725.
>
> 标签： 模拟、数组

给你一个数组 rectangles ，其中$ rectangles[i] = [l_i, w_i]$ 表示第 i 个矩形的长度为$ l_i $、宽度为 $w_i$ 。

如果存在 k 同时满足$ k <= l_i$ 和 $k <= w_i$ ，就可以将第 i 个矩形切成边长为 k 的正方形。例如，矩形 [4,6] 可以切成边长最大为 4 的正方形。

设 maxLen 为可以从矩形数组 rectangles 切分得到的 最大正方形 的边长。

请你统计有多少个矩形能够切出边长为 maxLen 的正方形，并返回矩形 数目 。

```java
class Solution {
    public int countGoodRectangles(int[][] rectangles) {
        int maxLen = 0;
        int cnt = 0;
        for (int i = 0;i < rectangles.length;i++){
            int len = Math.min(rectangles[i][0],rectangles[i][1]);
            if (maxLen == len){
                cnt += 1;
            }else if (maxLen < len){
                maxLen = len;
                cnt = 1;
            }
        }
        return cnt;
    }
}
```

