# 链表

> 注：**由于链表类型题解题方法比较单一，因此只给出解题大致思路，部分给出代码。**

#### 单链表中倒数第K个结点

采用倒退的想法，开始时一个标记指向尾结点的下一个null，另外一个指向倒数第k个结点，然后让这两个结点一次向前遍历，当原本指向倒数第k个结点的标记指向了头节点（此时可以理解为一个初始状态），而另外一个指向的正数的第k个结点，那么我们再正向来想，开始的状态就是上述的初始状态，那么逐个向后遍历，就可以**在初始状态指向正数第k个结点的指针指向尾部null时，原本指向头结点的指针就指向了倒数第k个结点。**

> 总结：两个指针，一个A指向 head，一个B指向第 K 个结点，然后一起向后遍历，当B指向尾结点时，A指向了倒数第 K 个结点。



#### 判断链表是否有环

使用两个指针，$\textit{fast}$与 $\textit{slow}$。它们起始都位于链表的头部。随后，$\textit{slow}$指针每次向后移动一个位置，而 $\textit{fast}$指针向后移动两个位置。如果链表中存在环，则 $\textit{fast}$指针最终将再次与 $\textit{slow}$指针在环中相遇。





#### 判断两个链表是否有交点

```
给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。
```

<img src="链表.assets/160_example_1.png" alt="img" style="zoom:50%;" />

> 方法1：**哈希**
>
> 哈希表内存储链表A的每个结点的地址，然后遍历链表B，当在哈希表中存在与链表B中结点地址相同的结点，那么这个就是公共结点[交点]
>
> 方法2：**双指针**
>
> - 只有当链表 `headA` 和 `headB` 都不为空时，两个链表才可能相交。因此首先判断链表 `headA `和 `headB` 是否为空，如果其中至少有一个链表为空，则两个链表一定不相交，返回 null。
>
>
> - 当链表  `headA`  和  `headB` 都不为空时，创建两个指针 `pA ` 和 `pB`，初始时分别指向两个链表的头节点 `headA` 和  `headB` ，然后将两个指针依次遍历两个链表的每个节点。具体做法如下：
>   - 每步操作需要同时更新指针 `pA ` 和 `pB`。
>   - 如果指针 `pA ` 不为空，则将指针 `pA ` 移到下一个节点；如果指针 `pB` 不为空，则将指针 `pB` 移到下一个节点。
>   - 如果指针 `pA ` 为空，则将指针 `pA ` 移到链表 `headB` 的头节点；如果指针 `pB` 为空，则将指针`pB` 移到链表  `headA` 的头节点。
>   - 当指针 `pA ` 和 `pB` 指向同一个节点或者都为空时，返回它们指向的节点或者 `null`。



#### 环形链表 II

给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 如果链表无环，则返回 `null`。

**首先**：判断链表是否有环（见上述题解）。如果没有环直接返回null，否则继续寻找 **环的入口**

设链表中环外部分的长度为 a。$\textit{slow}$指针进入环后，又走了 b 的距离与 $\textit{fast}$相遇。此时，$\textit{fast}$指针已经走完了环的 n 圈，因此它走过的总距离为 $a+n(b+c)+b=a+(n+1)b+nc$。

![image-20220616202556329](链表.assets/image-20220616202556329.png)

根据题意，任意时刻，$\textit{fast}$指针走过的距离都为 $\textit{slow}$指针的 2 倍。因此，我们有

$a+(n+1)b+nc=2(a+b) \implies a=c+(n-1)(b+c)$

有了 $a=c+(n-1)(b+c)$的等量关系，我们会发现：从相遇点到入环点的距离加上 n−1 圈的环长，恰好等于从链表头部到入环点的距离。

因此，当发现 $\textit{slow}$与 $\textit{fast}$相遇时，我们再额外使用一个指针 $\textit{ptr}$。起始，它指向链表头部；随后，它和 $\textit{slow}$每次向后移动一个位置。最终，它们会在入环点相遇。

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null) {
            return null;
        }
        ListNode slow = head, fast = head;
        while (fast != null) {
            slow = slow.next;
            if (fast.next != null) {
                fast = fast.next.next;
            } else {
                return null;
            }
            if (fast == slow) {
                ListNode ptr = head;
                while (ptr != slow) {
                    ptr = ptr.next;
                    slow = slow.next;
                }
                return ptr;
            }
        }
        return null;
    }
}
```

#### 合并有序链表组

给定一个链表数组，每个链表都已经按升序排列。请将所有链表合并到一个升序链表中，返回合并后的链表。

```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```

**分治合并**：

```java
public class Solution {
    private ListNode mergeTwoList(ListNode A,ListNode B){
        if (A == null || B == null){
            return A != null ? A : B;
        }
        ListNode ans = new ListNode(-1);
        ListNode t = ans;
        ListNode ha = A, hb = B;
        while (ha != null && hb != null){
            if (ha.val <= hb.val){
                t.next = ha;
                ha = ha.next;
            }else{
                t.next = hb;
                hb = hb.next;
            }
            t = t.next;
        }
        t.next = ha != null ? ha.next : hb.next;
        return ans.next;
    }
    private ListNode merge(ListNode [] lists,int l, int r){
        if (l == r){
            return lists[l];
        }else if (l > r) return null;
        int mid = l + ((l + r) >> 1);
        return mergeTwoList(merge(lists,l,mid),merge(lists,mid+1,r));
    }
    public ListNode mergeKLists(ListNode[] lists) {
        return merge(lists,0,lists.length-1);
    }
}
```

时间复杂度：考虑递归「向上回升」的过程——第一轮合并 $\frac{k}{2}$组链表，每一组的时间代价是 O(2n)；第二轮合并 $\frac{k}{4}$组链表，每一组的时间代价是 O(4n)......所以总的时间代价是 $O(\sum_{i = 1}^{\infty} \frac{k}{2^i} \times 2^i n) = O(kn \times \log k)$，故渐进时间复杂度为 $O(kn \times \log k)$。

**优先级队列**：

```java
class node{
    int val;
    ListNode Node;
    public node(int val,ListNode Node){
        this.val = val;
        this.Node = Node;
    }
}
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        Queue<node> pq = new PriorityQueue<>(new Comparator<node>() {
            @Override
            public int compare(node o1, node o2) {
                return o1.val - o2.val;
            }
        });
        for (ListNode list : lists){
            if(list != null)
                pq.offer(new node(list.val,list));
        }
        ListNode head = new ListNode(-1);
        ListNode tail = head;
        while (!pq.isEmpty()){
            node first = pq.poll();
            tail.next = first.Node;
            tail = tail.next;
            if (first.Node.next != null){
                pq.offer(new node(first.Node.next.val,first.Node.next));
            }
        }
        return head.next;
    }
}
```

