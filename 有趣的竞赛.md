#### Round 1：将标题首字母大写

> 题目来源：LeetCode 5960

给你一个字符串 `title` ，它由单个空格连接一个或多个单词组成，每个单词都只包含英文字母。请你按以下规则将每个单词的首字母 **大写** ：

- 如果单词的长度为 `1` 或者 `2` ，所有字母变成小写。
- 否则，将单词首字母大写，剩余字母变成小写。

请你返回 **大写后** 的 `title` 。

题目解析：

比较简单..直接撸了

```java
class Solution {
    public String capitalizeTitle(String title) {
        String lowtitle = title.toLowerCase();
        String [] words = lowtitle.split(" ");
        StringBuilder ans = new StringBuilder(lowtitle.length());
        for (int i = 0;i < words.length;i++){
            if (words[i].length() < 3){
                ans.append(words[i]);
             if (i != words.length-1)
                    ans.append(" ");
                continue;
            }
            char head = words[i].charAt(0);
            if (head >= 'a' && head <= 'z'){
                head = (char)(head - 32);
            }
            ans.append(head);
            ans.append(words[i].substring(1));
            if (i != words.length-1){
                ans.append(" ");
            }
        }
        return ans.toString();
    }
}
```



#### Round 2：链表最大孪生和

> 题目来源：LeetCode 5961

在一个大小为 `n` 且 `n` 为 **偶数** 的链表中，对于 `0 <= i <= (n / 2) - 1` 的 `i` ，第 `i` 个节点（下标从 **0** 开始）的孪生节点为第 `(n-1-i)` 个节点 。

- 比方说，`n = 4` 那么节点 `0` 是节点 `3` 的孪生节点，节点 `1` 是节点 `2` 的孪生节点。这是长度为 `n = 4` 的链表中所有的孪生节点。

**孪生和** 定义为一个节点和它孪生节点两者值之和。

给你一个长度为偶数的链表的头节点 `head` ，请你返回链表的 **最大孪生和** 

题目解析：

比较简单,直接撸...

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public int pairSum(ListNode head) {
        int[] arr = new int[100000];
        ListNode now = head;
        int idx = 0;
        while (now != null){
            arr[idx++] = now.val;
            now = now.next;
        }
        int len = idx;
        int maxval = Integer.MIN_VALUE;
        for (int i = 0;i <= len / 2 -1;i++){
            if (arr[i] + arr[len-1-i] > maxval){
                maxval = arr[i] + arr[len-1-i];
            }
        }
        return maxval;
    }
}
```

#### Round 3：连接两字母单词得到的最长回文串

> 题目来源：LeetCode 5962

给你一个字符串数组 `words` 。`words` 中每个元素都是一个包含 **两个** 小写英文字母的单词。

请你从 `words` 中选择一些元素并按 **任意顺序** 连接它们，并得到一个 **尽可能长的回文串** 。每个元素 **至多** 只能使用一次。

请你返回你能得到的最长回文串的 **长度** 。如果没办法得到任何一个回文串，请你返回 `0` 。

**回文串** 指的是从前往后和从后往前读一样的字符串。

题目解析：



```java
class Solution {
    public int longestPalindrome(String[] words) {
        Map<String,Integer> m = new HashMap<>();
        for (int i = 0;i < words.length;i++){
            if (m.get(words[i]) == null){
                m.put(words[i],1);
            }else{
                m.put(words[i],m.get(words[i]) + 1);
            }
        }
        int maxlen = Integer.MIN_VALUE;
        int nowlen = 0;
        boolean centerok = false;
        for (int i = 0;i < words.length;i++){
            //如果本身就是回文串
            if (words[i].charAt(0) == words[i].charAt(1)){
                int cnt = m.get(words[i]);
                if (cnt % 2 == 1){
                    if (centerok == false){
                        nowlen += cnt * 2;
                        centerok = true;
                    }else{
                        nowlen += (cnt-1) * 2;
                    }
                }else{
                    nowlen += cnt * 2;
                }
                m.put(words[i],0);
            }else{//本身不是回文串
                StringBuilder sb = new StringBuilder(2);
                sb.append(words[i].charAt(1));
                sb.append(words[i].charAt(0));
                if (m.get(sb.toString()) == null) continue;
                int precnt = m.get(words[i]);
                int anocnt = m.get(sb.toString());
                int mincnt = Math.min(precnt,anocnt);
                m.put(words[i],precnt-mincnt);
                m.put(sb.toString(),anocnt-mincnt);
                nowlen += mincnt * 4;
            }
        }
        return nowlen;
    }
}
```



#### Round 4：用邮票贴满网格

> 题目来源：LeetCode 5931

给你一个 `m x n` 的二进制矩阵 `grid` ，每个格子要么为 `0` （空）要么为 `1` （被占据）。

给你邮票的尺寸为 `stampHeight x stampWidth` 。我们想将邮票贴进二进制矩阵中，且满足以下 **限制** 和 **要求** ：

1. 覆盖所有 **空** 格子。
2. 不覆盖任何 **被占据** 的格子。
3. 我们可以放入任意数目的邮票。
4. 邮票可以相互有 **重叠** 部分。
5. 邮票不允许 **旋转** 。
6. 邮票必须完全在矩阵 **内** 。

如果在满足上述要求的前提下，可以放入邮票，请返回 `true` ，否则返回 `false` 。



```java
//此答案只通过了 65/66 最后一个死也不知道怎么回事
class Solution {
  public int getHcango(int[][] grid,int x,int y){
        //向上下拓展
        int lines = 0;
        for (int i = x;i < grid.length;i++){
            if (grid[i][y] == 0) lines += 1;
            else break;
        }
        for (int i = x-1;i >=0;i--){
            if (grid[i][y] == 0) lines += 1;
            else break;
        }
        return lines;
    }
    public int getWcango(int[][] grid,int x,int y){
        //向左右拓展
        int colums = 0;
        for (int j = y;j < grid[0].length;j++){
            if (grid[x][j] == 0) colums += 1;
            else break;
        }
        for (int j = y-1;j >= 0;j--){
            if (grid[x][j] == 0) colums += 1;
            else break;
        }
        return colums;
    }
    public boolean possibleToStamp(int[][] grid, int stampHeight, int stampWidth) {
        int minH = Integer.MAX_VALUE;
        int minW = Integer.MAX_VALUE;
        if (grid == null) return true;
        if (stampHeight == 1 && stampWidth == 1) return true;
        int[][][] dp = new int[grid.length][grid[0].length][2];
        for (int i = 0;i < grid.length;i++){
            for (int j = 0;j < grid[0].length;j++){
                //如果是1直接跳过
                if (grid[i][j] == 1) continue;
                //判断当前点的上一个点是否测试过
                if (i-1 >= 0 && grid[i-1][j] == 0){
                    dp[i][j][0] = dp[i-1][j][0];
                }else{
                    dp[i][j][0] = getHcango(grid,i,j);
                }
                minH = Math.min(minH,dp[i][j][0]);
                //如果能够放的高度小于邮票高度，则返回False
                if (minH < stampHeight) return false;
                if (j-1 >= 0 && grid[i][j-1] == 0){
                    dp[i][j][1] = dp[i][j-1][1];
                }else{
                    dp[i][j][1] = getWcango(grid,i,j);
                }
                minW = Math.min(minW,dp[i][j][1]);
                //如果能够放的宽度小于邮票宽度，则返回False
                if (minW < stampWidth) return false;
            }
        }
        return true;
    }
}
```



> 总结：此次排名800多...最后一题亏啊...就差一个例子了，然后前面第一道题傻逼了开始，然后耽误了时间....