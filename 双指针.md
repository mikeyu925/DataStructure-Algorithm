

# 双指针

> 双指针类型的题目有三种：
>
> - 对撞指针[左右两指针向中间缩小]
>   - 要处理排序数组（或链接列表）并需要查找满足某些约束的一组元素的问题
> - 滑块指针[类似窗口长度动态变化的滑动窗口算法]  右"吞"左"吐"
>   - 查找最长/最短的子字符串、子数组或所需的值
>   - 解决一些查找满足一定条件的连续区间 或 长度 的问题
> - 快慢指针[常用于链表]
>   - 判断链表是否有环
>   - 删除链表倒数的第几个元素

## 对撞指针

### **独木舟**

（贪心+双指针）

```
题目描述
​ 一群人去旅行，要租用独木舟，每艘独木舟最多乘两人，且所有独木舟有一个统一的载重限度。给出独木舟的载重限度和每个人的体重，现求最少需要租用多少独木舟。
输入
​ 第一行一个整数 w，表示独木舟的载重量。（80≤w≤200）
​ 第二行一个整数 n，表示旅游人数。 （1≤n≤30000）
​ 接下来 n 行，每行一个数表示 ai，即每个人的重量 （5≤ai≤w）
输出
​ 输出一个数表示最少需要的独木舟数量。
```

> 独木舟的载重量是==约束==

重量大的尽可能和能够一起坐船的人里面较轻的去匹配。

```cpp
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

int w,n,ans = 0;

int main(){
    cin>>w>>n;
    vector<int> a(n);
    vector<bool> isOn(n,false);
    for(int i = 0;i < n;i++){
        cin>>a[i];
    }
    sort(a.begin(),a.end());
    int l = 0,r = n-1;
    while(l <= r){
        if(a[l] + a[r] <= w){ //如果两者重量和低于载重值，则匹配
            l++;
            r--;
            ans++;
        }else{//如果两者和大于载重值，则重量大的单独匹配
            r--;
            ans++;
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

### 两数之和

```
给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。
函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。

numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 <= answer[0] < answer[1] <= numbers.length 。
你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。
```

> 约束: `a + b = target`

```
输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
```

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int n = numbers.size();
        int left = 0,right = n-1;
        while(left < right){
            if(target == numbers[left] + numbers[right]){
                return {left+1,right+1};
            }else if(target > numbers[left] + numbers[right]) left++;
            else right--;
        }
        return {};
    }
};
```

### 三数之和

```
给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```

> 注意：题目要求找出的答案是==不重复的==。比如[-1,0,1,2,-1,-4]
>
> - 重复类型1：顺序改变，但内容一样，即(-1,0,1)和(0,-1,1)是重复的
> - 重复类型2：设下标为0和4的 -1分为为-1和-1'，那么(-1,0,1)和(-1',0,1)也是重复的
>
> 对于重复类型1：我们可以自己==规定自己找到的三元组答案(a,b,c)是非降序的==，即a≤b≤c，也就可以排除重复的元素。因此，我们需要首先进行排序，这样遍历数组得到的答案都是非降序的，也就保证了==答案不重复==。
>
> 对于重复类型2：当我们将数组排序过后，假设得到了[-4,-1,-1',0,1,2]，假设当前得到了结果(-1,0,1)，然后下一次对于a将会到达-1'，此时我们需要跳过。
>
> 为什么会要想到要用==双指针==？
>
> 首先我们肯定是要分别遍历数组，来标定a,b,c的值然后判断其是否符合a+b+c = 0。对于已经排序的数组，当我们获得了一组数(a,b,c)符合a+b+c=0时，对于b下一个值b'一定符合b≤b',为了依旧符合a+b'+c'=0，那么c'一定符合c'≤c，因此对于非降序的数组，b是从左向右遍历[升序]，c是从右向左[降序]，这便联想到了双指针

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        int n = nums.size();
        //对数组进行排序
        sort(nums.begin(),nums.end());
        vector<vector<int>> ans;
        //固定a
        for(int a = 0;a < n;a++){
            //如果a重复，直接跳过
            if(a > 0 && nums[a] == nums[a-1]) continue;
            int target = -nums[a];
            //初始化b和c的边界
            int b = a + 1,c = n-1;
            while(b < c){
                //如果b也重复上一次，那么直接跳过
                if(b > a + 1 && nums[b] == nums[b-1]){
                    b++;
                    continue;
                }
                //如果符合条件，加入结果；不符合则变化双指针
                if(nums[b] + nums[c] ==  target) {
                    ans.push_back({nums[a],nums[b],nums[c]});
                    b++;
                }else if(nums[b] + nums[c] < target){
                    b++;
                }else{
                    c--;
                }
            }            
        }
        return ans;
    }
};
```

### 盛水最多的容器

```
给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。
找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
```

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
```

> Area = min(height[left],height[right]) * (right - left)

![盛水最多的容器](双指针.assets/盛水最多的容器.jpg)

```cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
        int n = height.size();
        int left = 0,right = n-1;
        int ans = -1;
        while(left < right
              //获取当前面积
            int area = min(height[left],height[right]) * (right - left);
              //更新最大值
            ans = max(area,ans);
              //选择排除哪一个木棒
            height[left] <= height[right] ? left++ : right--;
        }
        return ans;
    }
};
```



## 滑块指针

> 与滑动窗口的思想差不多一样



## 快慢指针





还有种划分方式是：

1. 两个指针分别指向两个序列
2. 两个指针指向同一个序列