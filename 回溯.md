# 回溯

回溯的思想很重要，因为它和搜索、递归都有着极大地联系，也可以说搜索就是递归的一种具化形式。比如递归的全排列问题，DFS搜索的N皇后问题，其实本源就是回溯的思想。

回溯要非常注意的三个点：

- 已选择序列：也就是已经做出的选择组成的序列（路径）。
- 选择列表：也就是当前可以做的下一步选择。
  - 有时候是两种可能：当前层`选择`该结点和`不选择`该节点。
  - 有时候要列举后面的所有元素，还可能是图论里面下一步去哪（遍历整个图）
- 结束条件：也就是到达决策树底层（没有选择）的条件。

这个是一般回溯算法常用的框架，在你没有想法的时候可以试着套套~

```python
path = []
def backtrack(路径, 选择列表):
    if 满足结束条件/没有选择了:
        path.add(路径)
        return
    
    for 选择 in 选择列表:
        做选择===> 标记
        backtrack(路径, 选择列表)
        撤销选择===> 撤销标记
```

通常在我们遇到的回溯法解决的问题中，还可以进行一些优化，比如`剪枝`、`去重`等

**剪枝**：

1. **记忆化搜索**：`把已经计算出的答案记录到一个数组`里面，这样后面如果要用的话，就可以直接取出来，不必再搜索一遍。
2. **排序**：有时只需要一个解便可退出循环，此时`不同的搜索顺序可能对时间影响会很大`。比方类似背包，确定要拿多少东西，我们从大的拿，放不下就可以直接剪枝了，可以节省时间。
3. **前缀和剪枝**：可以用这种方法来`判断说是不是后面所有元素都加上也不够（或者刚好）`，那么就不必再往后搜索。

**去重**：

1. 利用集合set：把所有答案先放入一个set中，等遍历结束，再把所有答案放回到数组。

2. 记录一层内每一个数是否有被用过，例如：递增子序列、活字印刷

   - 这种在答案序列有序的情况下是比较好用的 ==> 回溯前先排序

#### 示例.所有子集的异或总和再求和

> 题目来源：Leetcode 1863.

一个数组的 异或总和 定义为数组中所有元素按位 XOR 的结果；如果数组为 空 ，则异或总和为 0 。

> 例如，数组 [2,5,6] 的 异或总和 为 2 XOR 5 XOR 6 = 1 。

给你一个数组 nums ，请你求出 nums 中每个 子集 的 异或总和 ，计算并返回这些值相加之 和 。

注意：在本题中，元素 相同 的不同子集应 多次 计数

**解题思路**：

**子集问题**常常可以采用**回溯**的方法解决，对于数组中的每个元素，我们有两种选择（选或不选），从而交叉构成了不同的子集。

![异或子集和](F:\Typora\Picture\leetcode\异或子集和.jpg)

```java
//java版本
class Solution {
    int ans;
    int n;
    /**
     @val:截至目前的异或值
     @idx:当前的索引下标
    */
    public void dfs(int val,int idx,int[] nums){
        //没有选择了,结束
        if(idx == n){
            ans += val;
            return;
        }
        //不选择（跳过）当前点
        dfs(val,idx + 1,nums);
        //选择当前点
        dfs(val^nums[idx],idx + 1,nums);
    }
    public int subsetXORSum(int[] nums) {
        ans = 0;
        n = nums.length;
        dfs(0,0,nums);
        return ans;
    }
}
```



#### 示例. 二进制手表

> 题目来源：Leetcode.401

二进制手表顶部有 4 个 LED 代表 **小时（0-11）**，底部的 6 个 LED 代表 **分钟（0-59）**。每个 LED 代表一个 0 或 1，最低位在右侧。

给你一个整数 turnedOn ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 按任意顺序 返回答案。

小时不会以零开头：

> 例如，"01:00" 是无效的时间，正确的写法应该是 "1:00" 。

分钟必须由两位数组成，可能会以零开头：

> 例如，"10:2" 是无效的时间，正确的写法应该是 "10:02" 。

解题思路：

本题有很多比较好的解题方法，但是毕竟在讲回溯，因此我们还是用回溯方法求解。

对于每个点有两种选择

- 选择
  - 选则是否会越界？
- 不选择

终止条件：选够了turnedOn个点 或者 没有选择了

> 注：没有选择了 并且 选择的点数小于turnedOn个点说明不符合要求。

```java
class Solution {
    int hour;  //表示“时”的值
    int minute;  //表示“分”的值
    List<String> ans; //结果存放列表
    /**
    @hourVal: 当前"时"的值
    @minuteVal: 当前"分"的值
    @indx: 索引0~5在分区域，6~9在时区域
    @count: 已经选择了几个位置
    @turnedOn: 总共需要选择几个位置
    */
    public void dfs(int hourVal,int minuteVal,int indx,int count,int turnedOn){
        //如果 没有选择了 或者 选够了 
        if(count == turnedOn || indx == 10){
            String time = null;
            if(minuteVal < 10){
                time = hourVal + ":0" + minuteVal;
            }else{
                time = hourVal + ":" + minuteVal;
            }
            //如果选够了，否则就是没选择了（比如一个都没选或者选的数量小于count)
            if(count == turnedOn){
                ans.add(time);//保存结果
            }
            return;
        }
        //如果当前在 "分"区域
        if(indx >= 0 && indx < 6){
            //判断如果选了该 点 是否会越界；不越界就选
            if(minuteVal + (int)Math.pow(2,indx) <= 59){
                dfs(hourVal,minuteVal + (int)Math.pow(2,indx),indx+1,count+1,turnedOn);
            }
            //不选择该点，即跳过
            dfs(hourVal,minuteVal,indx+1,count,turnedOn);
        }else{//当前在 "时"区域
            if(hourVal + (int)Math.pow(2,indx-6) <= 11){
                dfs(hourVal + (int)Math.pow(2,indx-6),minuteVal,indx+1,count+1,turnedOn);
            }
            dfs(hourVal,minuteVal,indx+1,count,turnedOn);
        }
    }
    public List<String> readBinaryWatch(int turnedOn) {
        //初始化
        ans = new ArrayList<String>();
        hour = 0;
        minute = 0;
        //回溯，深度优先搜索
        dfs(0,0,0,0,turnedOn);
        return ans;
    }
}
```



#### 示例. 格雷编码

> 题目来源：Leetcode.89
>
> 相似题目：1238. 循环码排列

n 位格雷码序列 是一个由 $2n$ 个整数组成的序列，其中：

1. 每个整数都在范围 $[0,2n-1]$内（含 0 和 $2n - 1$ ）
2. **第一个整数是 0**
3. 一个整数在序列中出现 不超过一次 
4. 每对 **相邻 整数的二进制表示 恰好一位不同** ，且 **第一个** 和 **最后一个** 整数的二进制表示 **恰好一位不同**

给你一个整数 n ，返回任一有效的 n 位格雷码序列 。

**解题思路**：

我们假设 n = 2，则其中一个结果是$[00,01,11,10]$。由题可以，开始时设`val = 0 = 00（二进制表示）`，那么第 4 条约束限制，下一个数只能是`01 或 10`，我们选择将低位设置为1，即`01`，加入结果集合中。此时`val = 01`，我们依然从低位开始设置为 1 ，显然不能`01 ==> 01`，因为`01`已经存在了，违反了第 3 条约束。那么我们就设置下一位`01 ==> 11`，符合要求，加入结果集。显然后面就是不断的递归。

![格雷编码](F:\Typora\Picture\leetcode\格雷编码.jpg)

```java
class Solution {
    List<Integer> ans;
    public void dfs(int val,int n,boolean[] label){
        label[val] = true; //标志已经保存
        ans.add(Integer.valueOf(val)); //存入结果
        for(int i = 0;i < n;i++){//开始依次从低位设置1
            int tmp =val | (1 << i);
            if(label[tmp] != true){//判断是否被标志了
                dfs(tmp,n,label);
            }
        }
    }
    public List<Integer> grayCode(int n) {
        int num = (int)Math.pow(2,n); 
        boolean [] label = new boolean[num];//标志数组
        ans = new ArrayList<Integer>(); //创建一个对象保存结果
        dfs(0,n,label);
        return ans;
    }
}
```





#### 示例. 组合总和II

> 题目来源：Leetcode.216

找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

>- 所有数字都是正整数。
>- 解集不能包含重复的组合。

```java
class Solution {
    List<List<Integer>> ans;  //存放最后所有结果
    List<Integer> tmp;   //存放一种结果
    public void dfs(int val,int sumval,int cnt,int k,int n){
        tmp.add(Integer.valueOf(val));
        if(cnt == k){
            if(sumval == n){
                //注意：因为是引用对象，不能使用ans.add(tmp);不然修改tmp,ans中的tmp也会被修改
                ans.add(new ArrayList<Integer>(tmp));
            }
            tmp.remove(Integer.valueOf(val));
            //返回前是不是要移除对应元素
            return ;
        }
        //为了防止子集重复，可以使得选择的元素都是递增的
        for(int i = val+1;i <= 9;i++){
            if(sumval + i > n) break;
            dfs(i,sumval+i,cnt+1,k,n);
        }
        tmp.remove(Integer.valueOf(val));
    }
    public List<List<Integer>> combinationSum3(int k, int n) {
        tmp = new ArrayList<Integer>();
        ans = new ArrayList<List<Integer>>();
        //初始点，每个点都选择一遍
        for(int i = 1;i <= 9 ;i++){
            dfs(i,i,1,k,n);
        }
        return ans;
    }
}
```

```java
    List<List<Integer>> ans;
    List<Integer> tmp;
    public void dfs(int val,int sumval,int k,int n){
        if(val > 9) return;
        if(tmp.size() == k){
            if(sumval == n){
                ans.add(new ArrayList<Integer>(tmp));
            }
            return ;
        }
        //选择当前点
        tmp.add(Integer.valueOf(val + 1));
        dfs(val+1,sumval+val+1,k,n);
        tmp.remove(tmp.size() - 1);
        //不选择当前点--->跳过
        dfs(val+1,sumval,k,n);
    }
    public List<List<Integer>> combinationSum3(int k, int n) {
        tmp = new ArrayList<Integer>();
        ans = new ArrayList<List<Integer>>();
        dfs(0,0,k,n);
        return ans;
    }
```



#### 示例. 递增子序列

> 题目来源：Leetcode.419

给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。

数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。

```
输入：nums = [4,6,7,7]
输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]

输入：nums = [4,4,3,2,1]
输出：[[4,4]]
```

解题思路：

其实这道题就是求子序列，只是加了个限制条件（子序列是递增的）。子序列比较棘手的一点就是其中的重复元素处理。如示例一：`4,6,7(第一个)`和`4,6,7(第二个)`属于同一种情况。因此，去重就是这道题的一大要点。

去重：对于重复的元素，我们可以进行及时的剪枝来进行。我们规定，对于`4,6,7(第一个)`和`4,6,7(第二个)`这种情况，我们选择第2种来作为添加元素（即选择后一个）

举个例子：比如ABBCD，如果我们选择了第1个B，那么剩余的字符就变成了ABCD，这个时候我们再选择第2个B是可以的。但如果我们没选择第1个B，直接选择第2个B，那么剩余的字符就是ABCD，和上面重复了。所以代码大致是这样的

```java
if (i - 1 >= 0 && chars[i] == chars[i - 1] && !used[i - 1]) continue;
```

![递增子序列](F:\Typora\Picture\leetcode\递增子序列.jpg)

```java
class Solution {
    List<List<Integer>> paths;
    List<Integer> path;
    public void dfs(int idx,int last,int [] nums){
        //没有选择了
        if(idx == nums.length){
            if(path.size() > 1){//判断数组内元素
                paths.add(new ArrayList<Integer>(path)); //注意：要创建一个新的对象
            }
            return ;
        }
        //如果当前元素  大于 上一个元素，则是递增的
        if(idx == 0 || nums[idx] >= last){ //保证序列是递增的
            path.add(nums[idx]); //添加元素（选择）
            dfs(idx+1,nums[idx],nums);  //进行 下一层递归
            path.remove(path.size() - 1); //撤销，恢复到原来的状态
        }
        //如果当前元素 == 上一个元素，就结束
        if(nums[idx] != last){ //剪枝去重
            dfs(idx+1,last,nums);
        }
        
    }
    public List<List<Integer>> findSubsequences(int[] nums) {
        paths =new ArrayList<List<Integer>>();
        path = new ArrayList<Integer>();
        dfs(0,Integer.MIN_VALUE,nums);
        return paths;
    }
}
```

#### 示例. 活字印刷

> 题目来源：Leetcode.1079

你有一套活字字模 `tiles`，其中每个字模上都刻有一个字母 `tiles[i]`。返回你可以印出的非空字母序列的数目。

**注意：**本题中，每个活字字模只能使用一次。

```
输入："AAB"
输出：8
解释：可能的序列为 "A", "B", "AA", "AB", "BA", "AAB", "ABA", "BAA"。
```

![image.png](F:\Typora\java\pic\10.png)

这道题有几要点：

1. **结果不重复**，所以每次选择的时候都只能从前往后选。同时`[A，B]`和`[B，A]`被认为是两种不同的结果。

2. **每个字符只能被使用一次**，因此使用一个数组`boolean[] used`来标记有没有被使用。

3. **结果非空**，即不能一个都不选

4. **对于输入ABBCD，$A_1 BCD$ 和 $A_2BCD$ 相当于重复**，因此如果我们选择了第1个A，那么剩余的字符就变成了ABCD，这个时候我们再选择第2个A是可以的。但如果我们没选择第1个A，直接选择第2个A，那么剩余的字符就是ABCD，和上面重复了。

   > 也就是说，对于一个位置，我们如果选择了相同的字符，那么结果会重复。
   >
   > **解决办法**：先排序，然后如果上一个没有用，并且当前字符和上一个字符相同，则跳过



方法一：排序 + 回溯

```java
class Solution {
    char[]  arrtile; //存储每个字符
    int ans = 0;  //结果
    boolean[] used;  //标记数组
    public void dfs(int idx){
        //没有选择了，到底层了
        if(idx == arrtile.length){
            return ;
        }
        //从头开始一个一个选择 ==> 对于要点1
        for(int i = 0;i < arrtile.length;i++){
            //每个字符只能用一次，如果用过就跳过  ==> 对于要点2
            if(used[i]) continue;   
            //如果上一个没有用，并且当前字符和上一个字符相同，则跳过 ==> 对于要点4
            if(i > 0 && arrtile[i] == arrtile[i-1] && !used[i-1]) continue;
            //更新结果，只有选了更新结果 ==> 对于要点3
            ans++;
            //标记
            used[i] = true;
            dfs(idx+1);
            //撤销标记
            used[i] = false;
        }
    }
    public int numTilePossibilities(String tiles) {
        arrtile = tiles.toCharArray();//String ==> char[]
        used = new boolean[arrtile.length]; 
        Arrays.sort(arrtile); //排序，这样相同的字符一定是相邻的
        dfs(0); //进行第一次递归
        return ans;
    }
}
```

方法二：统计字符+回溯

```java
class Solution {
    char[]  arrtile;
    int ans = 0;
    int[] cnt = new int[26];
    public void dfs(int idx){
        if(idx == arrtile.length) return;
        //依次判断每个位置是否都有
        for(int i = 0;i < 26;i++){
            if(cnt[i] == 0) continue; //相当于剪枝
            cnt[i] -= 1;
            ans++;
            dfs(idx+1);
            cnt[i] += 1;
        }
    }
    public int numTilePossibilities(String tiles) {
        arrtile = tiles.toCharArray();
        for(int i = 0;i < arrtile.length;i++){ //统计字符个数
            cnt[arrtile[i] - 'A'] += 1;
        }
        dfs(0);
        return ans;
    }
}
```

#### 示例. 火柴拼正方形

> 题目来源：Leetcode.437

输入火柴的数目，每根火柴用其长度表示。输出即为是否能用所有的火柴拼成正方形。

```
输入: [1,1,2,2,2]
输出: true

解释: 能拼成一个边长为2的正方形，每边两根火柴。
```

对于给定的若干根火柴，我们需要：

- 将它们分成四组，每一根火柴恰好属于其中的一组；
- 每一组火柴的长度之和都相同，等于所有火柴长度之和的四分之一。

使用深度优先搜索枚举出所有的分组情况，并对于每一种情况，判断是否满足上述的两个条件。

依次对每一根火柴进行搜索，当搜索到第` i `根火柴时，我们可以把它放到四组中的任意一种。对于每一种放置方法，我们继续对第` i + 1` 根火柴进行递归搜索。当我们搜索完全部的 N 根火柴后，再判断每一组火柴的长度之和是否都相同。

```java
class Solution {
    List<Integer> nums; //存储每条火柴长度
    int[] sums;  //存储每条边的当前长度和
    int edgeLen;  //每条边的边长
    public boolean dfs(int idx){
        //所有火柴均分组完成
        if(idx == nums.size()){
            //四组火柴长度相同
            if(sums[0] == sums[1] && sums[1] == sums[2] && sums[3] == sums[2]){
                return true;
            }
        }
        //获取当前火柴长度
        int tmp = nums.get(idx);
        //依次将该火柴放置在4组中
        for(int i = 0; i < 4;i++){
            if(sums[i] + tmp > edgeLen) continue;//如果 放入该火柴，长度超过要求边长，则放弃放入该组
            sums[i] += tmp; //放入
            if(dfs(idx+1)) return true; //进入下一层递归 ==> 放下一根火柴
            sums[i] -= tmp; //拿出
        }
        return false;
    }

    public boolean makesquare(int[] matchsticks) {
        //如果火柴长度小于4，则不可能拼成
        if(matchsticks == null || matchsticks.length < 4){
            return false;
        }
        //求取火柴长度和
        int perimeter = 0;
        for(int matchstick: matchsticks){
            perimeter += matchstick;
        }
        //因为要求所有火柴均使用，则必须能够被4整除
        if(perimeter % 4 != 0) return false;
        this.edgeLen = perimeter / 4; //求取每条边要求的长度
        this.sums = new int[]{0,0,0,0}; //初始化每组中的长度和
        this.nums = Arrays.stream(matchsticks).boxed().collect(Collectors.toList()); //int[]转List
        Collections.sort(this.nums, Collections.reverseOrder()); //排序
        return dfs(0); //递归
    }
}
```

#### 示例. 火柴拼正方形

> 题目来源：Leetcode.437

给你一个字符串 s ，请你拆分该字符串，并返回拆分后唯一子字符串的最大数目。

字符串 s 拆分后可以得到若干 非空子字符串 ，这些子字符串连接后应当能够还原为原字符串。但是拆分出来的每个 子字符串 都必须是 唯一的 。

注意：子字符串 是字符串中的一个连续字符序列

**解题思路**：

首先需要一个集合Map或者Set来记录有哪些 子字符串 已经使用了。

定义递归函数`dfs(int idx,String s,int count)`，idx表示起始搜索索引位置，count表示当前有了几个子字符串。对于从起始位置 idx ，我们可以将  $s[idx,i]，i \in (idx,len(s))$ 加入结果，然后继续递归

```java
class Solution {
    //记录已经存储了哪些字符串
    Map<String,Integer> m = new HashMap<String,Integer>();
    //最终结果
    int ans = Integer.MIN_VALUE;

    public void dfs(int idx,String s,int count){
        //如果没有选择了，更新答案
        if(idx == s.length()){
            ans = Math.max(ans,count);
            return ;
        }
        //依次遍历所有从当前位置idx开始的所有子字符串
        for(int i = idx;i < s.length();i++){
            String sub = s.substring(idx,i+1); //获取子字符串
            if(m.get(sub) != null && m.get(sub) == 1) continue; //如果已经存在，跳过
            m.put(sub,1); //进行记录
            dfs(i+1,s,count+1);  //进入下一层递归
            m.put(sub,-1); //撤销记录
        }
    }
    public int maxUniqueSplit(String s) {
        dfs(0,s,0);
        return ans;
    }
}
```





