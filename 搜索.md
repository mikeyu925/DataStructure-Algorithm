# 深度优先搜索

## 相同的树

```
给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。
如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

示例 1：
输入：p = [1,2,3], q = [1,2,3]
输出：true
```

![img](https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg)

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

    bool func(TreeNode * p,TreeNode * q){
        if(p == nullptr && q != nullptr || p != nullptr && q == nullptr){
            return false;
        }else if(p == nullptr && q == nullptr){
            return true;
        }
        if(p->val != q->val) return false;
        if(func(p->left,q->left) && func(p->right,q->right)) return true;
        else return false;
    }

    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(func(p,q)){
            return true;
        }else{
            return false;
        }
    }
};
```

## 对称二叉树

```
给定一个二叉树，检查它是否是镜像对称的。
例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

```cpp
class Solution {
public:

    bool func(TreeNode * l,TreeNode * r){
        //左空右不空 或者 左不空右空 均不符合对称
        if(l == nullptr && r != nullptr || l != nullptr && r == nullptr){//&& 优先级 大于 ||
            return false;
        }else if(l == nullptr && r == nullptr){
            //两边均空符合对称
            return true;
        }
        //两边值不等则不符合对称
        if(l->val != r->val) return false;
        //检查镜像是否对称
        if(func(l->right,r->left) && func(l->left,r->right)) return true;
        else return false;
    }

    bool isSymmetric(TreeNode* root) {
        //起始是空树，直接返回真
        if(root == nullptr) return true;
        if(func(root->left,root->right)) return true;
        else return false;
    }
};
```
















# 广度优先搜索

## 二叉树的最小深度

```
给定一个二叉树，找出其最小深度。
最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

输入：root = [3,9,20,null,null,15,7]
输出：2
```

> **说明：**叶子节点是指没有子节点的节点。

![img](https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg)

```cpp
class Solution {
public:
    //创建一个自定义结构体，存放结果
    struct node{
        TreeNode * nodeAdr;
        int step;
    };
    queue<node> q;
    int minDepth(TreeNode* root) {
        if(root == nullptr) return 0;
        //初始化队列
        q.push((node){root,1});
        while(!q.empty()){
            node temp = q.front();
            q.pop();
            //当左右子树均空时，此结点为孩子结点
            if(temp.nodeAdr->left == nullptr && temp.nodeAdr->right == nullptr) return temp.step;
            //左孩子节点不空则入队，并将深度+1
            if(temp.nodeAdr->left)
                q.push((node){temp.nodeAdr->left,temp.step + 1});
            //右孩子节点不空则入队，并将深度+1
            if(temp.nodeAdr->right)
            q.push((node){temp.nodeAdr->right,temp.step + 1});
        }
        return -1;
    }
};
```

