

# 动态规划

有一说一，这个东西是真的难，不过我觉得通过 思考+刷题 是可以解决大部分的DP的。加油！打工人!

> 刷题怎么刷呢？也是从简单=>中等=>苦难吗？本人的路线是：先去找一个简单的动态规划类型题(比如去Leetcode刷)=>写完后查看与该题类似的题目=>然后根据这道题的经验看能否应用到类似的DP问题中. 这样循序渐进的同时也让你掌握了一系列问题的解决套路。

> 动态规划是一种将**原始问题分解成多个规模较小的子问题，而各个子问题之间相互联系，最终由子问题的解合并成原始问题**解的算法

动态规划问题的一般形式就是来==求最值==，因此当遇到求最大值/最小值等问题时，可以考虑一手是不是要用动态规划，此时你就要考虑该题符不符合其==四要素==了，不符合的还是另想办法！

动态规划算法四要素：

- 最优子结构

  > 当一个问题的最优解必然包含其子问题的最优解时，称该问题具有最优子结构。

  > 子问题：对于一个问题而言，只有规模比该问题小、其他均与该问题一致的问题才可称为其子问题，同时，子问题不会对规模等大的问题造成影响[**无后效性**]

- 重叠子问题

  > 当求取子问题解的时候，往往会出现许多**重复计算**。而动态规划是先解决小的问题，当后面再次出现该子问题时，可以直接求解

- 状态与状态转移方程

  > 动态规划是一种**自底向上**解决问题的思想，“状态”就是子问题的解，”状态转移方程“就是子问题之间的递推关系[说白了就是递推公式]

- 边界条件

  > 边界条件就是程序的停止条件。

```
递归算法通常是自顶向下构造函数，而动态规划为自底向上构造程序结构的算法思想。简单来说，动态就是先解决小问题，然后大问题的解可以由小问题的解直接转换求得。
```

动态规划最难的部分就是写出`动态转移方程`，这里有几点需要关心：

1. 最小的子问题的情况是什么?
2. 一个问题有哪些状态？
3. 对于每个当前的状态，可以选择什么？
4. 如何通过dp数组来表示你的"状态和选择"



**常见问题类型**：

- xxx的方式有几种/组合问题

- 最大/最小值等问题

  > 上面这两类问题难度一般较高，会仔细讲

- 明显递推方式的问题$,  f(x) 由 f(x-1)得来$

**常见优化**：

- 空间上原来二维数组采用滚动数组变为一维
- 原来的一维采用O(1)的变量代替



### **最大/最小值类型**

#### 例：打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     	偷窃到的最高金额 = 1 + 3 = 4 。
```

下面给了两种解题方案，体会一下状态转移的重要性。

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        //dp[i][0]:上一个i-1没偷，当前偷之后的最多金额
        //dp[i][1]:上一个i-1没偷，当前也没偷的最多金额
        //dp[i][2]:上一个i-1偷了，当前不偷的最多金额
        vector<vector<int>> dp(n,vector<int> (3,0));
        dp[0][0] = nums[0];
        dp[0][1] = 0;
        dp[0][2] = 0;
        for(int i=1;i<n;i++){
            //上一个没偷：那么上一个状态只可能是dp[i-1][1]或者dp[i-1][2].同时当前偷了，需要加上当前金额，取两者最大值
            dp[i][0] = max(dp[i-1][1],dp[i-1][2]) + nums[i];
            //上一个没偷：那么上一个状态只可能是dp[i-1][1]或者dp[i-1][2]，当前也不偷，取上一个状态两者最大值
            dp[i][1] = max(dp[i-1][1],dp[i-1][2]);
            //上一个偷了，当前状态即为上一次偷之后的状态，上一次只有可能dp[i-1]0]偷了
            dp[i][2] = dp[i-1][0];
        }
        //返回3者可能最大值
        return max(max(dp[n-1][0],dp[n-1][1]),dp[n-1][2]);
    }
};
```

空间优化：

```cpp
//空间优化
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        //dp[0]:上一个没偷，当前偷之后的最多金额
        //dp[1]:上一个没偷，当前也没偷的最多金额
        //dp[2]:上一个偷了，当前不偷的最多金额
        vector<int> dp(3,0);
        dp[0] = nums[0];
        dp[1] = 0;
        dp[2] = 0;
        for(int i=1;i<n;i++){
            //暂存dp[2];
            int tdp2 = dp[2];
            //上一个偷了，当前状态即为上一次偷之后的状态，上一次只有可能dp[0]偷了
            dp[2] = dp[0];
            //上一个没偷：那么上一个状态只可能是dp[1]或者dp[2].同时当前偷了，需要加上当前金额，取两者最大值
            dp[0] = max(dp[1],tdp2) + nums[i];
            //上一个没偷：那么上一个状态只可能是dp[1]或者dp[2]，当前也不偷，取上一个状态两者最大值
            dp[1] = max(dp[1],tdp2);

        }
        //返回3者可能最大值
        return max(max(dp[0],dp[1]),dp[2]);
    }
};
```

不要急，我们再看一下另外一个代码，这个输入比较常见的动态规划的框架类型。

我们定义dp表的意义为dp[i]]表示对于`nums[0]~nums[i]的房屋所能偷的最大金额`，`那么对于第0~i的房屋所能偷的最大金额取决于0~i-1的房屋偷的金额(此时第i个屋子就不能偷了)和0~i-2的房屋的最大值+第i个房屋的金额这两者的较大值。`

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.empty()) {
            return 0;
        }
        int size = nums.size();
        //只有一间房则肯定偷
        if (size == 1) {
            return nums[0];
        }
        //创建dp表 dp[i]表示对于nums[0]~nums[i]的房屋所能偷的最大金额
        vector<int> dp = vector<int>(size, 0);
        //dp表的初始情况初始化
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        for (int i = 2; i < size; i++) {
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[size - 1];
    }
};
```

> 我们可以看出，dp表的定义方式不同，我们解题的框架就不太相同，但是总体思想都是通过先前状态来推导当前的最优状态。
>
> 其中，第二种方法为比较常见的dp表定义方式

#### 例：打家劫舍II

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方**所有的房屋都 围成一圈** ，这意味着**第一个房屋和最后一个房屋是紧挨着的**。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。

> 题目是对原本的升级版，其实就是将原本的数组修改为了循环数组，解决方案和之前一样，只是我们需要遍历两次。分别求`0~n-2范围内房屋的可以偷到金额最大值`和`0~n-1范围内房屋的可以偷到金额最大值`，两者取较大值即可.

```cpp
class Solution {
public:
    /*此部分将原本的dp表进行了压缩，因为dp[i]只和dp[i-1]和dp[i-2]有关*/
    int getmaxRobval(int start,int end,vector<int> & nums){
        int first = nums[start],second = max(nums[start],nums[start+1]);
        //不太理解的就把first看作dp[i-2],second看作dp[i-1]
        for(int i = start + 2;i <= end;i++){
            int temp = second;//暂存second,因为接下来要修改second
            second = max(nums[i]+first,second);
            first = temp;
        }
        return second;
    }
    
    int rob(vector<int>& nums) {
        int n = nums.size();
        if(n == 1)return nums[0];//如果只有一个房屋直接偷
        if(n == 2)return max(nums[0],nums[1]);//两个房屋偷贵的
        //因为首尾相连，因此需要两次判断，并取较大值。
        return max(getmaxRobval(0,n-2,nums),getmaxRobval(1,n-1,nums));
    }
};
```

#### 例：打家劫舍III

在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

```
输入: [3,2,3,null,3,null,1]

     3
    / \
   2   3
    \   \ 
     3   1

输出: 7 
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.
```

刚看这道题还是比较懵的，但是后来想想就是跟前面的思想一样的，只是此时创建数组形式的dp表不太现实了，因此改为哈希表来作为dp表。

思考，对于结点x，以x为根的树能够被偷的最大金额有两种**状态**：`结点x被偷`和`结点x不被偷`。

对于**选择**，当`结点x被偷`时，那么两个子节点都不能被偷，当`结点x不被偷`时，两个子节点可以被偷，也可以不被偷，取两者较大的值。

**此时，一个思路就慢慢浮现...**

我们可以用 selectMap(x) 表示偷 x 节点的情况下，x 节点的子树上被偷的节点的最大权值和；noselectMap(x) 表示不选择 x 节点的情况下，x 节点的子树上被选择的节点的最大权值和；l 和 r 代表 x 的左右孩子。

- 当 x 被选中时，x 的左右孩子都不能被选中，故 x 被选中情况下子树上被选中点的最大权值和为 l 和 r 不被选中的最大权值和相加，即 $selectMap(x) = noselectMap(l)+noselectMap(r)$。
- 当 x 不被选中时，x 的左右孩子可以被选中，也可以不被选中。对于 x 的某个具体的孩子 x，它对 x 的贡献是 x 被选中和不被选中情况下权值和的较大值。故 $noselectMap(x)=max\{selectMap(l),noselectMap(l)\}+max\{selectMap(r),noselectMap(r)\}$

至此，我们可以用哈希表`map<Treenode *,int>`来存 selectMap和 noselectMap 的函数值，用深度优先搜索的办法后序遍历这棵二叉树，我们就可以得到每一个节点的 selectMap和 noselectMap。

```cpp
class Solution {
public:
    map<TreeNode *,int> selectMap;
    map<TreeNode *,int> noselectMap;
    void dfs(TreeNode *root){
        if(!root) return;
        dfs(root->left);
        dfs(root->right);
        selectMap.insert(make_pair(root,root->val+noselectMap[root->left]+noselectMap[root->right]));
        noselectMap.insert(make_pair(root,max(selectMap[root->left],noselectMap[root->left])+max(selectMap[root->right],noselectMap[root->right])));
        
    }
    int rob(TreeNode* root){
        dfs(root);
        return max(selectMap[root],noselectMap[root]);
    }
};
```

#### 例：删除并获得点数

给你一个整数数组`nums`，你可以对它进行一些操作。每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。

开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。

```
输入：nums = [2,2,3,3,3,4]
输出：9
```

通过理解题目后，我们发现 不如我们挑选了值为 k 的元素，那么 k-1 和 k-2 的元素我就不能挑选了（也就是 相邻大小的值的元素 不能被选择）如果你做过`打家劫舍`那么你会突然意识到，这不就类似打家劫舍问题，偷其中一家，则相邻的就不能偷了。两者的原理是一样的，只不过 打家劫舍 问题是选择索引下标 （即，限制的是下标），而此题限制的是 值。下标是唯一的，但是值可能有很多重复的，因此，我们在进行选择前需要提前统计 值大小为 k 的元素的和 sum 是多少，并进行记录，我们可以用一个数组来进行存储，sums[k] = x 表示 `值大小为 k 的元素的和是 x`，之后我们就可以采用与打家劫舍相似的方法来处理 sums 数组。

```cpp
class Solution {
public:

    int rob(vector<int> &sums){
        int n = sums.size();
        if(n == 1) return sums[0];
        int first = sums[0],second = max(sums[0],sums[1]);
        for(int i = 2;i < n;i += 1){
            int tmp = second;
            second = max(first + sums[i],second);
            first = tmp;
        }
        return max(first,second);
    }
    int deleteAndEarn(vector<int>& nums) {
        int n = nums.size();
        vector<int> sums(10000+5,0);
        for(int i = 0;i < n;i++){
            sums[nums[i]] += nums[i];
        }
        return rob(sums);
    }
};
```

> 由此，我们可以看出，有些问题其实本质是相似的，只是需要再解决问题的时候进行一些逻辑转换，而这，也是比较难的，非常考验解题者的逻辑能力。



#### 例：股票买卖

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

```
输入：[7,1,5,3,6,4]
输出：5
```

我们还是看看**选择**先，对于每一天，可以选择买入、卖出、不买不卖三种选择。但是呢，题目具有一些限制条件，即**只能买卖一次股票**。

接下来就是定义dp表含义，我们定义`dp[i][0]`为在**第i天手上没有股票时的收益**，`dp[i][1]`为在**第i天手上持有股票时的收益**。考虑一下它可以由哪些状态转移过来呢？

显然`dp[i][0]`可以由**前一天没有股票今天也不买**和**前一天手持股票今天卖出**两种方式转移而来，即$dp[i][0] = max(dp[i-1][0],dp[i-1][1]+prices[i])$

对于`dp[i][1]`可以由前一天持有股票今天不卖和前一天没有股票今天买入两种方式转移，即$dp[i][1] = max(dp[i-1][1],-prices[i])$，这里为什么不是`dp[i-1][0]-prices[i]`而是`-prices[i]`呢？因为有一个限制条件：**只能买卖一次股票**。因此买股票时不能从前一天没有股票的状态转移而来，因为可能很早以前已经买过并卖出了。

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n == 0: return 0
        #dp[i][0]：至第i天，手里没有股票时的收益
        #dp[i][1]：至第i天，手里有股票时的收益
        dp = [[0 for i in range(2)] for j in range(n)]
        dp[0][0],dp[0][1] = 0,-prices[0]
        for i in range(1,n):
            dp[i][0] = max(dp[i-1][0],dp[i-1][1] + prices[i])
            dp[i][1] = max(dp[i-1][1],-prices[i])
        return dp[n-1][0]
```

这里贴一个python版的代码，希望大家能够在刷题的时候能多掌握几种语言，因为每种语言都有各自的优势，有的语言可以借助本身提供的数据结构来进行求解，会很方便。这里推荐python+Cpp两种方式刷题，当然java也是不错的选择。

#### 例：股票买卖II

给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。

计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

> 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

```
输入: prices = [7,1,5,3,6,4]
输出: 7
```

此题相较于上一题多了一个条件就是可以多次买卖股票，不过基本思想还是一样，我们还是按照上题创建dp表，只是在动态转移方程处需要进行修改。原本只能买卖一次，因此$dp[i][1] = max(dp[i-1][1],-prices[i])$，而此时可以多次买卖，因此可以由上一个没有股票时的状态转移而来，因此此时$dp[i][1] = max(dp[i-1][1],dp[i-1][0]-prices[i])$

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        /*
        dp[i][0]:到第i天手上没有股票时所获得最大利润
        dp[i][1]:到第i天手上有股票时所获得最大利润
        */
        vector<vector<int>> dp(n,vector<int> (2,0));
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        for(int i = 1;i < n;i++){
            dp[i][0] = max(dp[i-1][0],dp[i-1][1] + prices[i]);
            dp[i][1] = max(dp[i-1][1],dp[i-1][0] - prices[i]);
        }
        return dp[n-1][0];
    }
};
```

> 可以看到，其实大体思路是不变的，改变的只是题目的限制条件



#### 例：股票买卖III

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

> 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

```
输入：prices = [3,3,5,0,0,3,1,4]
输出：6
```

此题在上一题的基础上更新了限制条件，就是最多只能买卖两次股票。我们还是先考虑**选择**和**状态**，选择还是哪几个选择`保留、卖出、买入`，而状态变了，对于第i天，有5种状态：`一张没买、买了一张、卖了一张此时什么没有股票、买了第二张、卖了第二张股票`，我们还根据前面的两题的想法写出状态转移方程。但是我们要注意，`一张没买`的状态只能从`前一天一张没买的状态`进行转移。因此其值一直为0，我们可以将其省略，对于剩余4种状态，我们分别定义dp表将其对应。

-  dp`[i][0]`:在第i天时，手上持有一张股票时的最大利益
-  dp`[i][1]`:在第i天时，手上没有股票，并已经卖出了一次时的最大利益
-  dp`[i][2]`:在第i天时，手上持有第二次买入的股票时的最大利益
-  dp`[i][3]`:在第i天时，手上没有股票，已经完成两次卖出时的最大利益

则可以分别写出动态转移方程：

$dp[i][0] = max(dp[i-1][0],0 - prices[i])，此处的0 就是前一天一张没买的状态$

$dp[i][1] = max(dp[i-1][1],dp[i-1][0] + prices[i])$

$dp[i][2] = max(dp[i-1][2],dp[i-1][1] - prices[i])$

$dp[i][3] = max(dp[i-1][3],dp[i-1][2] + prices[i])$

最后的结果肯定就是最后一天两张都卖出的状态，即`dp[n-1][3]`

> 当然，因为第i天的状态只和第i-1天有关，因此可以进行状态压缩，减少空间复杂度如:  
>
> ```cpp
> buy1 = max(buy1,-prices[i]);
> sell1 = max(sell1,buy1+prices[i]);
> buy2 = max(buy2,sell1-prices[i]);
> sell2 = max(sell2,buy2+prices[i]);
> ```

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        dp = [ [0 for i in range(4)] for j in range(n) ]
        '''
        dp[i][0]:在第i天时，手上持有一张股票时的最大利益
        dp[i][1]:在第i天时，手上没有股票，并已经卖出了一次时的最大利益
        dp[i][2]:在第i天时，手上持有第二次买入的股票时的最大利益
        dp[i][3]:在第i天时，手上没有股票，已经完成两次卖出时的最大利益
        '''
        dp[0][0],dp[0][1],dp[0][2],dp[0][3] = -prices[0],0,-prices[0],0
        for i in range(1,n):
            dp[i][0] = max(dp[i-1][0],0 - prices[i])
            dp[i][1] = max(dp[i-1][1],dp[i-1][0] + prices[i])
            dp[i][2] = max(dp[i-1][2],dp[i-1][1] - prices[i])
            dp[i][3] = max(dp[i-1][3],dp[i-1][2] + prices[i])
        return dp[n-1][3]
```

> 记录一下：当我做到这里时，我发现好像如果能够用动态规划首先要了解清除状态和选择，因为这是你构建状态转移方程的源泉之一。

#### 例：股票买卖IV

给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

```
输入：k = 2, prices = [3,2,6,5,0,3]
输出：7
```

题目又得到了升级...，此时由原来的2次变为了k次，此时，如果你是一路认真做过来的，那么你应该会想到不就是把k=2的情况转换为一个k遍历，原理还是一样的。确实，原理还是一样的，只不过有许多细节需要注意。不管什么时候，你都要清除你的dp表的含义是什么？你的动态转移方程应该怎么来求。好的，我们来看一下。

我们定义`buys[i][j]表示第i天已经买卖了j次股票并且当前有股票时的最大收益`，定义`sells[i][j]:表示第i天已经买卖了j次股票并且当前没有股票时的最大收益`。当然你也可以定义成`dp[2][i][j]将buys和sells合并`，这里是为了方便讲解分开定义。

那么我们根据前几道股票买卖问题可以比较容易的推导出状态转移方程：

$sells[i][j] = max(sells[i-1][j],buys[i-1][j-1] + prices[i])$，$buys[i][j] = max(buys[i-1][j],sells[i-1][j] - prices[i])$

这里有个小细节需要注意`sells[i][j]是由buys[i-1][j-1] + prices[i]转移而来而不是buys[i-1][j]`，因为`buys[i-1][j-1]`表示前一天(i-1)交易了 j-1 次并且当前还有股票，将其在第 i 天交易，就得到了`sells[i][j]`，表示在第 i 天交易了 j 次并且没有股票。

另外，还有一些**注意事项**：

- 就是我们在第0天的时候，只有可能 也 最多可能交易0次，因此$sells[0][k]和buys[0][k],k\in[1,n)$都应该是一个无效的值，因此我们将其设置为一个极小值(因为我们是求极大值，因此其不会对结果造成影响)。
- 因为`sells`的转移方程为：$sells[i][j] = max(sells[i-1][j],buys[i-1][j-1] + prices[i])$，状态转移涉及到`buys[i-1][j-1]`，因此j肯定不可能从0开始遍历，**会造成数组访问越界**。但是我们又需要它！因此在每一天的开始时，我们需要对`buys[i][0]`初始化（`buys[0][0]`在最开始初始化了)
- 最后我们返回的是`sells[n-1][i]中的最大值`。

```cpp
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        if not prices: return 0
        n = len(prices)
        '''
        buys[i][j]:表示第i天已经买卖了j次股票并且当前有股票时的最大收益
        sells[i][j]:表示第i天已经买卖了j次股票并且当前没有股票时的最大收益
        '''
        buys = [[ 0 for i in range(k+1)] for j in range(n)]
        sells = [[0 for i in range(k+1)] for j in range(n)]
        buys[0][0] = -prices[0] #第0天买卖了0次并且当前有股票时受益为-prices[0]
        sells[0][0] = 0         #第0天买卖了0次并且当前没有股票时受益为0
        #第0天不可能交易任何股票，因此buys[0][i] (0,k] 都设置为一个无穷小数表示无效
        for i in range(1,k+1):
            buys[0][i] = sells[0][i] = float("-inf")
        for i in range(1,n): # 1 ~ n-1
            #因为sells[i][j]的动态转移需要用到buys[i-1][j-1]，而j是从1~k，需要对buys[i][0]进行计算
            buys[i][0] = max(buys[i-1][0],sells[i-1][0]-prices[i])
            for j in range(1,k+1): # 1 ~ k
                sells[i][j] = max(sells[i-1][j],buys[i-1][j-1] + prices[i])
                buys[i][j] = max(buys[i-1][j],sells[i-1][j] - prices[i])
        #print(sells[n-1])
        return max(sells[n-1])
```

这些基本上就是股票问题基本的解决方法了，有的时候题目还有添加什么`交易手续费`等等额外条件，其实就是对`动态转移方程`进行一些条件限制和修改而已。同时，对于`股票买卖IV`，还有一种`基于Wqs二分`的方法：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/solution/yi-chong-ji-yu-wqs-er-fen-de-you-xiu-zuo-x36r/

#### 例：最大连续子数组的和

给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
```

由题可知，所求的是连续子数组且其和最大。经过之前的训练，我们可以定义`dp[i]表示以nums[i]结尾的子数组所具有的最大和`。

> 有时候你可能不能一下想出比较好的dp定义方式，这个时候就要尝试定义，切记不要害怕去尝试！

我们为什么会想到这样的dp表定义方式呢？我们首先看题目：要求的是连续子数组。同时呢，又要求是最大和，便想到选择是：`对于一个nums[i]，加入或者不加入目前的最大连续子数组`，同时`又要维护连续的要求`，那么其只能选择`加入以nums[i-1]结尾的子数组的后面`或者`重新另起一个子数组`。这样不就可以想到定义`dp[i]表示以nums[i]结尾的子数组所具有的最大和`

那么状态转移方程也就出来了：$dp[i] = max(dp[i-1]+nums[i],nums[i])$

即，要么选择将nums[i]加入以nums[i-1]结尾的子数组后，要么就是将nums[i]作为一个新的子数组

```python
#python 3
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [0 for i in range(n)]
        dp[0] = nums[0]
        for i in range(1,n):
            dp[i] = max(dp[i-1]+nums[i],nums[i])
        return max(dp)
```



#### 例：乘积最大子数组

给你一个整数数组 `nums` ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

```
输入: [2,3,-2,4]
输出: 6
```

这题乍一看！好像跟上一道`最大连续子数组的和`，然后直接`定义dp[i]表示以nums[i]结尾的子数组所具有的最大乘积`并且一波操作写出状态转移方程$dp[i] = max(dp[i-1]*nums[i],nums[i])$，然后就提示**失败**，哈哈哈哈哈哈~

我们看一下为什么！如果经验老道的童鞋可能一眼就会看出 乘积 问题涉及的负数问题，即 负负得正 这一个坑。举个例子：

假设`nums = [3,-2,2,3,-2]`，显然最大连续子数组乘积是所有元素相乘为 72，但是按照我们上面定义的dp及状态转移方程，我们推导一下：`dp = [3,-2,2,6,-2]`，最后返回的是 6。为什么会这样呢？是因为`当前位置的最优解未必是由前一个位置的最优解转移得到的`。因为对于最后一个-2来说，它的最优子问题的解不是 6，而是 3 * -2 * 2 * 3 = -36，这是因为它本身是个负数，因此**期望有一个最小的数**和它相乘成为一个比较大的正数。===>因此我们在状态转移的时候就要考虑 符号的问题了 我们不仅需要知道`以nums[i]结尾的子数组所具有的最大乘积`还需要知道`以nums[i]结尾的子数组所具有的最小乘积`来进行状态转移。

考虑当前位置如果是**一个负数**的话，那么我们希望以它前一个位置结尾的某个段的积也是个负数，这样就可以负负得正，并且我们希望这个积**尽可能负得更多**，即尽可能小。如果当前位置是**一个正数**的话，我们更希望以它前一个位置结尾的某个段的积也是个正数，并且希望它**尽可能地大**。于是我们定义`dpMax[i]：以nums[i]结尾的子数组所具有的最大乘积`和`dpMin[i]：以nums[i]结尾的子数组所具有的最小乘积`

则状态转移方程：

$dpMax[i] = max(dpMax[i-1]*nums[i],dpMin[i-1]*nums[i],nums[i]);$

$dpMin[i] = min(dpMax[i-1]*nums[i],dpMin[i-1]*nums[i],nums[i]);$

最后返回的结果是`dpMax中的最大值`

```cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        vector<int> dpMax(n,0),dpMin(n,0);
        dpMax[0] = dpMin[0] = nums[0];
        for(int i = 1;i < n;i++){
            dpMax[i] = max(max(dpMax[i-1]*nums[i],dpMin[i-1]*nums[i]),nums[i]);
            dpMin[i] = min(min(dpMax[i-1]*nums[i],dpMin[i-1]*nums[i]),nums[i]);
        }
        return *max_element(dpMax.begin(), dpMax.end());
    }
};
```



### **xxx的方式有几种**/组合问题

> 这类问题也比较多，一般属于简单和中等难度题目。

#### 例： 不同路径 

> 题目来源：Leetcode 63

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

```
输入：m = 3, n = 7
输出：28
```

题目知道，我们在每个点的**选择**可以有“向下”或者"向右"。对于此题来说，**状态**就是从左上角至`[i][j]`点有多少。因此，对于当前的状态，可以由其左边的和上边的点状态转移过来。我们定义`dp[i][j]`的意义为：从左上角`[0][0]`至`[i][j]`有多少种路径，那么我们可以很容易推出递推公式：
$$
dp[i][j] =
\begin{cases} 
1,  & \text{if } i==0 \text{||}j == 0 \\
dp[i-1][j]+dp[i][j-1, & \text{if }  i \geq 1 \text{&&} j\geq1
\end{cases}
$$

```cpp
class Solution {
public:
    int uniquePaths(int m,int n)
    {
        vector<vector<int>> res(m);
        for (int i = 0; i < m; i++){
            res[i].resize(n);
        }
        //初始化
        res[0][0] = 1;
        for (int i = 1; i < n; i++){
            res[0][i] = 1;
        }
        for (int i = 1; i < m; i++){
            res[i][0] = 1;
        }
        //根据状态转移方程更新dp表
        for (int row = 1; row < m; row++){
            for (int col = 1; col < n; col++){
                res[row][col] = res[row-1][col] + res[row][col-1];
            }
        }
        return res[m-1][n-1];
    }
};
```



#### 例： 不同路径 II

> 题目来源：Leetcode 63

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。

```
输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
```

此题在上一题只是加上了一些限制条件，有的地方加上了石块不能经过，那么我们就按照题目要求意思，如果obstacleGrid`[i][j]`  == 1，那么到达该点的路径有0条。其余考虑点还是和上题一样。

```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        vector<vector<int>> dp(m,vector<int> (n,0));
        for(int i = 0;i < m;i++){
            if(obstacleGrid[i][0] == 1)
                break;
            dp[i][0] = 1;
        }
        for(int i = 0;i < n;i++){
            if(obstacleGrid[0][i] == 1)
                break;
            dp[0][i] = 1;
        }
        for(int i = 1;i < m;i++){
            for(int j = 1;j < n;j++){
                if(obstacleGrid[i][j] == 1) continue;
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
};
```



### **明显递推方式的问题**

这类问题比较明显，通常递归就可以解决，但是递归会消耗大量的栈空间。通过动态规划方法解决也是不错的方法。

比如常见的斐波那契数列等等，这类问题比较简单，就不细讲了。举个简单的例子应付一下哈哈哈哈

#### 例:获取生成数组中的最大值

> 题目来源：Leetcode 1646. 

给你一个整数 n 。按下述规则生成一个长度为 n + 1 的数组 nums ：

- nums[0] = 0
- nums[1] = 1
- 当$ 2 <= 2 * i <= n $时，$nums[2 * i] = nums[i]$
- 当 $2 <= 2 * i + 1 <= n $时，$nums[2 * i + 1] = nums[i] + nums[i + 1]$

要求：返回生成数组 nums 中的 **最大** 值。

```cpp
class Solution {
public:
    int getMaximumGenerated(int n) {
        vector<int> nums(n+1);
        if(n == 0) return 0;
        if(n == 1) return 1;
        int ans = 1;
        nums[0] = 0;
        nums[1] = 1;
        for(int i = 1;i <= n / 2;i++){
            //根据题目给的递推关系进行递推。
            nums[i*2] = nums[i];
            if(i * 2 + 1<= n){
                nums[i*2 + 1] = nums[i] + nums[i+1];
                ans = max(ans,max(nums[i*2],nums[i*2+1]));
            }else{
                ans = max(ans,nums[i*2]);
            }
        }
        return ans;
    }
};
```

