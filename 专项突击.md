#### 整数除法

给定两个整数 `a` 和 `b` ，求它们的除法的商 `a/b` ，要求不得使用乘号 `'*'`、除号 `'/'` 以及求余符号 `'%'` 。 

**注意：**

- 整数除法的结果应当截去（`truncate`）其小数部分，例如：`truncate(8.345) = 8` 以及 `truncate(-2.7335) = -2`
- 假设我们的环境只能存储 32 位有符号整数，其数值范围是 `[−231, 231−1]`。本题中，如果除法结果溢出，则返回 `231 − 1`

```
输入：a = 7, b = -3
输出：-2
解释：7/-3 = truncate(-2.33333..) = -2
```

位运算：

<img src="./专项突击.assets/image-20230222133543265.png" alt="image-20230222133543265" style="zoom:50%;" />

```go
func divide(a int, b int) int {
    if a == math.MinInt32 && b == -1{
        return math.MaxInt32
    }
    sign := 1
    if a > 0 && b < 0 || a < 0 && b > 0{
        sign = -1
    }

    a = abs(a)
    b = abs(b)
    
    ans := 0
    for i := 31;i >= 0;i--{
        if (a >> i) - b >= 0{
            a -= (b << i)
            ans += (1 << i)
        }
    }
    return ans * sign
}

func abs(a int) int{
    if a < 0{
        return -a
    }
    return a
}
```

#### 二进制加法

给定两个 01 字符串 `a` 和 `b` ，请计算它们的和，并以二进制字符串的形式输出。

输入为 **非空** 字符串且只包含数字 `1` 和 `0`。

**示例 1:**

```
输入: a = "11", b = "10"
输出: "101"
```

题目解析：

- 长串作为a串
- 字符串强转`[]byte`
- 字符串逆序
- 相加 「注意a长b短情况，要继续对a和进位值相加」
- 逆序结果返回

```go
func addBinary(a string, b string) string {
	// a串作为长串
	if len(a) < len(b) {
		a, b = b, a
	}
	// 强转
	ca := []byte(a)
	cb := []byte(b)

	reverse(ca)
	reverse(cb)

	n, m := len(a), len(b)
	add := 0
	i, j := 0, 0
	for i < n && j < m {
		t := (int(ca[i]-'0') + int(cb[j]-'0') + add) / 2
		ca[i] = (byte((int(ca[i]-'0')+int(cb[j]-'0')+add)%2) + '0')
		add = t
		i++
		j++
	}
	for ; i < n; i++ {
		t := (int(ca[i]-'0') + add) / 2
		ca[i] = (byte((int(ca[i]-'0')+add)%2) + '0')
		add = t
	}
	if add == 1 {
		ca = append(ca, byte('1'))
	}
	reverse(ca)
	return string(ca)
}

func reverse(s []byte) {
	n := len(s)
	for i, j := 0, n-1; i < j; {
		s[i], s[j] = s[j], s[i]
		i++
		j--
	}
}
```

#### 前n个数字二进制中1的个数

给定一个非负整数 `n` ，请计算 `0` 到 `n` 之间的每个数字的二进制表示中 1 的个数，并输出一个数组。

**示例 1:**

```
输入: n = 2
输出: [0,1,1]
解释: 
0 --> 0
1 --> 1
2 --> 10
```

动态规划

```go
func countBits(n int) []int {
    dp := make([]int,n+1)
    for i := 1;i <= n;i++{
        dp[i] = dp[i & (i - 1)] + 1 
    }
    return dp
}
```

#### 只出现一次的数字

给你一个整数数组 `nums` ，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次 。**请你找出并返回那个只出现了一次的元素。

**示例 1：**

```
输入：nums = [2,2,3,2]
输出：3
```

位运算：

除了只出现一次的数字，其他数字每位为1的个数一定是3的整数倍

```go
func singleNumber(nums []int) int {
    var ans int32 = 0 // 声明为int32是因为防止仅仅出现一次的数为负数
    for i := 31;i >= 0;i--{
        cnt := 0
        for _,v := range nums{
            cnt += (v >> i) & 1
        }
        cnt = cnt % 3
        if cnt == 1{
            ans = ans | (1 << i)
        }
    }
    return int(ans)
}
```



#### 单词长度的最大乘积

给定一个字符串数组 `words`，请计算当两个字符串 `words[i]` 和 `words[j]` 不包含相同字符时，它们长度的乘积的最大值。假设字符串中只包含英语的小写字母。如果没有不包含相同字符的一对字符串，返回 0。

**示例 1:**

```
输入: words = ["abcw","baz","foo","bar","fxyz","abcdef"]
输出: 16 
解释: 这两个单词为 "abcw", "fxyz"。它们不包含相同字符，且长度的乘积最大。
```

位运算、字符串压缩「由于只包含小写字母」

时间复杂度：O(n ^ 2)   空间复杂度：O(n)

```go
func maxProduct(words []string) int {
    n := len(words)
    masks := make([]int,n)
    for idx,word := range words{
        m := len(word)
        val := 0
        for i := 0;i < m;i++{
            val = val | (1 << int(word[i] - 'a'))
        }
        masks[idx] = val
    }
    ans := 0
    for i,v := range masks{
        for j := i + 1;j < n;j++{
            if v & masks[j] == 0{
                ans = max(ans,len(words[i]) * len(words[j]))
            }
        }
    }
    return ans
}

func max(a,b int )int{
    if a < b{return  b};return a
}
```

#### 排序数组中两个数字之和

给定一个已按照 **升序排列** 的整数数组 `numbers` ，请你从数组中找出两个数满足相加之和等于目标数 `target` 。

函数应该以长度为 `2` 的整数数组的形式返回这两个数的下标值*。*`numbers` 的下标 **从 0 开始计数** ，所以答案数组应当满足 `0 <= answer[0] < answer[1] < numbers.length` 。

假设数组中存在且只存在一对符合条件的数字，同时一个数字不能使用两次。

**示例 1：**

```
输入：numbers = [1,2,4,6,10], target = 8
输出：[1,3]
解释：2 与 6 之和等于目标数 8 。因此 index1 = 1, index2 = 3 。
```

**双指针**

时间复杂度：O(n)  空间复杂度：O(1)

```go
func twoSum(numbers []int, target int) []int {
    n := len(numbers)
    l,r := 0,n-1
    for ;l < r;{
        if numbers[l] + numbers[r] == target{
            break
        }else if numbers[l] + numbers[r] < target{
            l++
        }else{
            r--
        }
    }
    return []int{l,r}
}
```

#### 数组中和为 0 的三个数

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请

你返回所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

**示例 1：**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
```

题目解析：

先排序 + 双指针

注意考虑边界

时间复杂度： O(n^2)  空间复杂度：O(n)

```go
func threeSum(nums []int) [][]int {
    n := len(nums)
    sort.Slice(nums,func(i,j int) bool {
        return nums[i] < nums[j]
    }) // 升序排序 O(n logn)
  	ans := make([][]int,0) // ans := [][]int{}
    
    for i := 0;i < n;i++{
      // 优化1: 如果 nums[i] > 0 了，后面显然就不可能成立
        if nums[i] > 0{
            break
        }
      // 避免重复 
        if i > 0 && nums[i] == nums[i-1]{
            continue
        }
        l,r := i + 1,n - 1
        for ;l < r;{
          // 避免重复 注意考虑边界
            if l > i + 1  && l < n && nums[l] == nums[l-1]{
                l++
                continue
            }
            if l >= r {
                break
            }
            if nums[l] + nums[r] == -nums[i]{
                ans = append(ans,[]int{nums[i],nums[l],nums[r]})
                l++
            }else if nums[l] + nums[r] < -nums[i]{
                l++
            }else{
                r--
            }
        }
    }
    return ans
}
```

#### 和大于等于 target 的最短子数组

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其和 `≥ target` 的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

**示例 1：**

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

滑动窗口

```go
func minSubArrayLen(target int, nums []int) int {
    n := len(nums)
    l,r := 0,0
    windowVal := 0
    ans := 0x3f3f3f3f
    for r < n{
        windowVal += nums[r]
        for l <= r && windowVal >= target{
            ans = min(ans,r - l + 1)
            windowVal -= nums[l]
            l++
        }
        r++
    }
    if ans == 0x3f3f3f3f{
        return 0
    }
    return ans
}

func min(a,b int) int{
    if a < b{
        return a
    }
    return b
}
```



#### 乘积小于K的子数组

给定一个正整数数组 `nums`和整数 `k` ，请找出该数组内乘积小于 `k` 的连续的子数组的个数。 

**示例 1:**

```
输入: nums = [10,5,2,6], k = 100
输出: 8
解释: 8 个乘积小于 100 的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。
需要注意的是 [10,5,2] 并不是乘积小于100的子数组。
```

滑动窗口：**「当时没想出来，重点看一下」**

对于`[i,j]`，我们固定 j，如果 对于 i > p ，[i,j]的乘积小于k，并且 对于 i <= p,[i,j]乘积大于等于 k,则对于任意的 r > j，都存在 [i,r]的i不能小于等于p 「相当于枚举了右端点」

时间复杂度：O(n)  空间复杂度:O(1)

```go
func numSubarrayProductLessThanK(nums []int, k int) int {
    n := len(nums)
    if k == 0{
        return 0
    }
    ans := 0
    winVal,l := 1,0
    // 枚举窗口的右边界
    for r := 0;r < n;r++{
        winVal *= nums[r]
        // 缩小窗口至满足条件
        for l <= r && winVal >= k{
            winVal /= nums[l]
            l++
        }
        // 累加 以 nums[r] 结尾且符合条件的子数组
        ans += r - l + 1
    }

    return ans
}
```

#### 和为 k 的子数组

给定一个整数数组和一个整数 `k` **，**请找到该数组中和为 `k` 的连续子数组的个数。

**示例 1：**

```
输入:nums = [1,1,1], k = 2
输出: 2
解释: 此题 [1,1] 与 [1,1] 为两种不同的情况
```

题目解析：

前缀和 + 哈希表

时间：O(n) 空间：O(n)

```go
func subarraySum(nums []int, k int) int {
    n := len(nums)
    cnt := map[int]int{} // 记录有val个前缀和为key
    cnt[0] = 1 // 空数组相当于和为0
    sum := 0
    ans := 0
    for i := 0;i < n;i++{
        sum += nums[i]
        v := sum - k
        if c,ok := cnt[v]; ok{
            ans += c
        }
        cnt[sum] ++
    }
    return ans
}
```



####  0 和 1 个数相同的子数组

给定一个二进制数组 `nums` , 找到含有相同数量的 `0` 和 `1` 的最长连续子数组，并返回该子数组的长度。

**示例 1：**

```
输入: nums = [0,1]
输出: 2
说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。
```

将 0 看成 - 1，然后题目等价于求连续子数组和为0 的最长长度，和上题类似

时间：O(n) 空间：O(n)

```go
//   |----|--|
//     v   0

func findMaxLength(nums []int) int {
    n := len(nums)
    first := map[int]int{} // 第一次出现key的下标val
    first[0] = -1 // 初始化
    sum := 0
    ans := 0
    for i := 0;i < n;i++{
        if nums[i] == 0{
            sum--
        }else{
            sum++
        }
      // 如果之前出现该值，则说明另一段值的和就是0
        if idx,ok := first[sum];ok{
            ans = max(ans,i - idx)            
        }else{
            first[sum] = i
        }
    }
    return ans
}
func max(a,b int)int{
    if a < b{return b};return a
}
```



#### 左右两边子数组的和相等

给你一个整数数组 `nums` ，请计算数组的 **中心下标** 。

数组 **中心下标** 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。

如果中心下标位于数组最左端，那么左侧数之和视为 `0` ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。

如果数组有多个中心下标，应该返回 **最靠近左边** 的那一个。如果数组不存在中心下标，返回 `-1` 。

**示例 1：**

```
输入：nums = [1,7,3,6,5,6]
输出：3
解释：
中心下标是 3 。
左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，
右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。
```

前缀和：

时间复杂度: O(n) 空间：O(1)

```go
func pivotIndex(nums []int) int {
    n := len(nums)
    if n == 1{
        return 1
    }
    sum := 0
    for _,v := range nums{
        sum += v
    }
    nows := 0
    i := 0
    for ;i < n;i++{
        if sum - nums[i] - nows == nows{
            break
        }
        nows += nums[i]
    }
    if i == n{
        return - 1
    }
    return i
}
```

#### 二维子矩阵的和

给定一个二维矩阵 `matrix`，以下类型的多个请求：

- 计算其子矩形范围内元素的总和，该子矩阵的左上角为 `(row1, col1)` ，右下角为 `(row2, col2)` 。

实现 `NumMatrix` 类：

- `NumMatrix(int[][] matrix)` 给定整数矩阵 `matrix` 进行初始化
- `int sumRegion(int row1, int col1, int row2, int col2)` 返回左上角 `(row1, col1)` 、右下角 `(row2, col2)` 的子矩阵的元素总和。

**示例 1：**

![img](./专项突击.assets/1626332422-wUpUHT-image.png)

```
输入: 
["NumMatrix","sumRegion","sumRegion","sumRegion"]
[[[[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]],[2,1,4,3],[1,1,2,2],[1,2,2,4]]
输出: 
[null, 8, 11, 12]

解释:
NumMatrix numMatrix = new NumMatrix([[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]]);
numMatrix.sumRegion(2, 1, 4, 3); // return 8 (红色矩形框的元素总和)
numMatrix.sumRegion(1, 1, 2, 2); // return 11 (绿色矩形框的元素总和)
numMatrix.sumRegion(1, 2, 2, 4); // return 12 (蓝色矩形框的元素总和)
```

题目解析：

创建的前缀和矩阵的大小为：(n+1) * (m+1) 比较好

```go
type NumMatrix struct {
    presum [][]int
}

func Constructor(matrix [][]int) NumMatrix {
    n,m := len(matrix),len(matrix[0])
    numMatrix := NumMatrix{}
    numMatrix.presum = make([][]int,n+1)
    for i := 0;i <= n;i++{
        numMatrix.presum[i] = make([]int,m+1)
    }
    for i := 1;i <= n;i++{
        for j := 1;j <= m;j++{
            numMatrix.presum[i][j] = numMatrix.presum[i][j-1] + numMatrix.presum[i-1][j] - numMatrix.presum[i-1][j-1] + matrix[i-1][j-1];
        }
    }
    return numMatrix
}


func (this *NumMatrix) SumRegion(row1 int, col1 int, row2 int, col2 int) int {
    return this.presum[row2+1][col2+1] - this.presum[row2+1][col1] - this.presum[row1][col2+1] + this.presum[row1][col1]
}
```



#### 字符串中的变位词

给定两个字符串 `s1` 和 `s2`，写一个函数来判断 `s2` 是否包含 `s1` 的某个变位词。

换句话说，第一个字符串的排列之一是第二个字符串的 **子串** 。 

**示例 1：**

```
输入: s1 = "ab" s2 = "eidbaooo"
输出: True
解释: s2 包含 s1 的排列之一 ("ba").
```

题目解析：

```go
func checkInclusion(s1 string, s2 string) bool {
    n,m := len(s1),len(s2)
    if n > m{
        return false
    }

    // O(n)
    cnt := make([]int,26)
    for i := 0;i < n;i++{
        cnt[s1[i] - 'a']--
        cnt[s2[i] - 'a']++
    }
    diff := 0
    // O(26)
    for _,v := range cnt{
        if v != 0{
            diff++
        }
    }
    if diff == 0{
        return true
    }
    // O(m - n)
    for i := n;i < m;i++{
        x,y := s2[i] - 'a',s2[i - n] - 'a'
        if x == y{
            continue
        }
        if cnt[x] == 0{
            diff++
        }
        cnt[x]++
        if cnt[x] == 0{
            diff--
        }

        if cnt[y] == 0{
            diff++
        }
        cnt[y]--

        if cnt[y] == 0{
            diff--
        }
        
        if diff == 0{
            return true
        }
        
    }
    return false
    
}
```





#### 字符串中的所有变位词

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **变位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**变位词** 指字母相同，但排列不同的字符串。 

**示例 1：**

```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的变位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的变位词。
```

题目解析：

方法同上一题一样：

```go
func findAnagrams(s string, p string) []int {
    ans := []int{}
    n,m := len(s),len(p)
    if n < m{
        return ans
    }

    cnt := make([]int,26)
    for i := 0;i < m;i++{
        cnt[s[i] - 'a']++
        cnt[p[i] - 'a']--
    }

    diff := 0
    for _, v := range cnt{
        if v != 0{
            diff ++
        }
    }
    
    if diff == 0{
        ans = append(ans,0)
    }

    for i := m;i < n;i++{
        x,y := s[i] - 'a',s[i - m] - 'a'
        if cnt[x] == 0{
            diff++
        }
        cnt[x] ++
        if cnt[x] == 0{
            diff--
        }
        
        if cnt[y] == 0{
            diff++
        }   
        cnt[y] --
        if cnt[y] == 0{
            diff--
        }

        if diff == 0{
            ans = append(ans, i - m + 1)
        }
    }
    return ans
}
```



#### 不含重复字符的最长子字符串

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长连续子字符串** 的长度。

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子字符串是 "abc"，所以其长度为 3。
```

哈希表 + 滑动窗口

```go
func lengthOfLongestSubstring(s string) int {
    n := len(s)
    l, r := 0,0
    cnt := map[int]int{}
    ans := 0

    for r < n{
        cnt[int(s[r] - 'a')]++
        for cnt[int(s[r] - 'a')] > 1{
            cnt[int(s[l] - 'a')]--
            l++
        }
        ans = max(ans,r - l + 1)
        r++
    }
    return ans
}

func max(a,b int) int{
    if a < b{
        return b
    }
    return a
}
```



#### 含有所有字符的最短字符串

给定两个字符串 `s` 和 `t` 。返回 `s` 中包含 `t` 的所有字符的最短子字符串。如果 `s` 中不存在符合条件的子字符串，则返回空字符串 `""` 。

如果 `s` 中存在多个符合条件的子字符串，返回任意一个。

**注意：** 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。

**示例 1：**

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC" 
解释：最短子字符串 "BANC" 包含了字符串 t 的所有字符 'A'、'B'、'C'
```

滑动窗口

```go
func minWindow(s string, t string) string {
    n := len(s)
    m := len(t)
    if n < m{
        return ""
    }
    cntt := map[byte]int{}
    cnts := map[byte]int{}
    ans := 0x3f3f3f3f
    start := -1
  // 时间复杂度 O(C) C是字符集大小
    check := func() bool{
        for k,v := range cntt{
            if cnts[k] < v{
                return false
            }
        }
        return true
    }

    for i := 0;i < len(t);i++{
        cntt[t[i]]++
    }
    
    l,r := 0,0
  // 时间复杂度 O(n)
    for r < n{
        cnts[s[r]]++
        if check(){
            for check() {
                cnts[s[l]]--
                l++
            }
            len := r - l + 2
            if len < ans{
                ans = len
                start = l - 1
            }
        }
        r++
    }
    if start == -1{
        return ""
    }
    ss := make([]byte,ans)
    for i := start;i < start + ans;i++{
        ss[i - start] = s[i]
    }
    return string(ss)
}
```



#### 有效的回文

给定一个字符串 `s` ，验证 `s` 是否是 **回文串** ，只考虑字母和数字字符，可以忽略字母的大小写。

本题中，将空字符串定义为有效的 **回文串** 。 

**示例 1:**

```
输入: s = "A man, a plan, a canal: Panama"
输出: true
解释："amanaplanacanalpanama" 是回文串
```

```go
func isPalindrome(s string) bool {
    n := len(s)
    l,r := 0,n-1
    s = strings.ToLower(s)
    // fmt.Println(s)
    for l < r{
        for l < r && !((s[l] >= 'a' && s[l] <= 'z') || (s[l] >= '0' && s[l] <= '9')) {
            l++
        }

        for l < r && !((s[r] >= 'a' && s[r] <= 'z') || (s[r] >= '0' && s[r] <= '9')) {
            r--
        }

        if s[l] != s[r]{
            return false
        }
        l++
        r--
    }
    return true
}
```



#### 最多删除一个字符得到回文

给定一个非空字符串 `s`，请判断如果 **最多** 从字符串中删除一个字符能否得到一个回文字符串。

**示例 1:**

```
输入: s = "aba"
输出: true
```

```go
func validPalindrome(s string) bool {
    l,r := 0,len(s) - 1
    for l < r{
        if s[l] != s[r]{
            break
        }
        l++
        r--
    }
    return checkPalindrome(s,l+1,r) || checkPalindrome(s,l,r-1)
}

func checkPalindrome(s string,l,r int) bool{
    for l < r{
        if s[l] != s[r]{
            return false
        }
        l++
        r--
    }
    return true
}
```



#### 回文子字符串的个数

给定一个字符串 `s` ，请计算这个字符串中有多少个回文子字符串。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

**示例 1：**

```
输入：s = "abc"
输出：3
解释：三个回文子串: "a", "b", "c"
```

```go
func countSubstrings(s string) int {
    n,ans := len(s),0
    for i := 0;i < 2*n - 1;i++{
        l,r := i / 2,i / 2 + i % 2
        for l >= 0 && r < n && s[l] == s[r]{
            l--
            r++
            ans ++   
        }
    }
    return ans
}
```

