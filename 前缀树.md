

#### 实现前缀树

> 题目来源：LeetCode 剑指 Offer II 062
>
> 标签：集合、前缀树

Trie（发音类似 "try"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。

请你实现 Trie 类：

- Trie() 初始化前缀树对象。
- void insert(String word) 向前缀树中插入字符串 word 。
- boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。
- boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。

```java
//笨方法，时间复杂度较高，不过还是AC了
class Trie {
    Set<String> set;
    /** Initialize your data structure here. */
    public Trie() {
        set = new HashSet<String>();
    }

    /** Inserts a word into the trie. */
    public void insert(String word) {
        if (set.contains(word)){
            return ;
        }
        set.add(word);
    }

    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        if (set.contains(word)){
            return true;
        }
        return false;
    }

    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
        Iterator<String> iter = set.iterator();
        while (iter.hasNext()){
            String str = iter.next();
            if (str.length() < prefix.length()) continue;
            if (prefix.equals(str.substring(0,prefix.length()))){
                return true;
            }
        }
        return false;
    }
}
```

方法二：采用字典树的真实实现

Trie，又称前缀树或字典树，是一棵有根树，其每个节点包含以下字段：

- 指向子节点的指针数组$\textit{children}$。对于本题而言，数组长度为 26，即小写英文字母的数量。此时 $\textit{children}[0]$ 对应小写字母 a，$\textit{children}[1]$ 对应小写字母 b，…，$\textit{children}[25]$ 对应小写字母 z。
- 布尔字段 $\textit{isEnd}$，表示该节点是否为字符串的结尾。

```java
class Trie {
    private Trie [] children;
    private boolean end;
    /** Initialize your data structure here. */
    public Trie() {
        children = new Trie[26];
        end = false;
    }

    /** Inserts a word into the trie. */
    public void insert(String word) {
        Trie node = this;
        for (int i = 0;i < word.length();i++){
            char ch = word.charAt(i);
            int idx = ch - 'a';
            if (node.children[idx] == null){
                node.children[idx] = new Trie();
            }
            node = node.children[idx];
        }
        node.end = true;
    }

    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        Trie node = searchPrefix(word);
        return node != null && node.end;
    }

    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
        return searchPrefix(prefix) != null;
    }
    
    private Trie searchPrefix(String prefix){
        Trie node = this;
        for (int i = 0;i < prefix.length();i++){
            char ch = prefix.charAt(i);
            int idx = ch - 'a';
            if (node.children[idx] == null){
                return null;
            }
            node = node.children[idx];
        }
        return node;
    }
}
```



#### 替换单词

> 题目来源：LeetCode 剑指 Offer II 063
>
> 标签：前缀树

在英语中，有一个叫做 词根(root) 的概念，它可以跟着其他一些词组成另一个较长的单词——我们称这个词为 继承词(successor)。例如，词根an，跟随着单词 other(其他)，可以形成新的单词 another(另一个)。

现在，给定一个由许多词根组成的词典和一个句子，需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。

需要输出替换之后的句子。

 ```
输入：dictionary = ["cat","bat","rat"], sentence = "the cattle was rattled by the battery"
输出："the cat was rat by the bat"
 ```

```java
//前缀树实现-->通过上一题稍作修改即可
class Trie {
    private Trie [] children;
    private boolean end;
    /** Initialize your data structure here. */
    public Trie() {
        children = new Trie[26];
        end = false;
    }
    /** Inserts a word into the trie. */
    public void insert(String word) {
        Trie node = this;
        for (int i = 0;i < word.length();i++){
            char ch = word.charAt(i);
            int idx = ch - 'a';
            if (node.children[idx] == null){
                node.children[idx] = new Trie();
            }else if (node.end){
            	break;
            }
            node = node.children[idx];
        }
        node.end = true;
    }
    public String getMinPrefix(String word){
        StringBuilder sb = new StringBuilder();
        Trie node = this;
        for (int i = 0;i < word.length();i++){
            char ch = word.charAt(i);
            int idx = ch - 'a';
            if (node.children[idx] == null || node.end == true) break;
            sb.append(ch);
            node = node.children[idx];
        }
        if (node.end){
            return sb.toString();
        }
        return null;
    }
}
class Solution {
    public String replaceWords(List<String> dictionary, String sentence) {
        StringBuilder sb = new StringBuilder();
        Trie tree = new Trie();
        for (int i = 0;i < dictionary.size();i++){
            tree.insert(dictionary.get(i));
        }
        String []words = sentence.split(" ");
        for (String word:words){
            String newword = tree.getMinPrefix(word);
            if (newword != null){
                sb.append(newword);
            }else{
                sb.append(word);
            }
            sb.append(" ");
        }
        return sb.toString().strip();
    }
}
```

#### 神奇的字典

> 题目来源：LeetCode 剑指 Offer II 064
>
> 标签：前缀树、深度优先搜索

设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 **互不相同** 。 如果给出一个单词，请判定能否只将这个单词中**一个**字母换成另一个字母，使得所形成的新单词存在于已构建的神奇字典中。

实现 `MagicDictionary` 类：

- `MagicDictionary()` 初始化对象
- `void buildDict(String[] dictionary)` 使用字符串数组 `dictionary` 设定该数据结构，`dictionary` 中的字符串互不相同
- `bool search(String searchWord)` 给定一个字符串 `searchWord` ，判定能否只将字符串中 **一个** 字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回 `true` ；否则，返回 `false` 。



```java
//字典树
class Trie{
    public Trie [] children;
    public boolean isend;
    Trie(){
        children = new Trie[26];
        isend = false;
    }
    public void insert(String str){
        Trie node = this;
        for (int i = 0;i < str.length();i++){
            char ch = str.charAt(i);
            int idx = ch - 'a';
            if (node.children[idx] == null){
                node.children[idx] = new Trie();
            }
            node = node.children[idx];
        }
        node.isend = true;
    }
}

class MagicDictionary {
    private Trie tree;
    /** Initialize your data structure here. */
    public MagicDictionary() {
        tree = new Trie();
    }

    public void buildDict(String[] dictionary) {
        for (String word : dictionary){
            tree.insert(word);
        }
    }
    private boolean dfs(Trie node,String word,int idx,int edit){
        if (node == null){
            return false;
        }
        //如果进行了一次修改并且成功匹配了前缀树
        if (node.isend == true && idx == word.length() && edit == 1){
            return true;
        }
        //匹配当前第idx个字符
        if (idx < word.length() && edit <= 1){
            boolean found = false;
            for (int j = 0;j < 26 && !found;j++){
                //如果当前第idx个字符 和 其中一个成功匹配，不会增加edit次数，否则进行一次修改
                int next = (j == (word.charAt(idx) - 'a') ? edit : edit + 1);
                found = dfs(node.children[j],word,idx+1,next);
            }
            return found;
        }
        //修改次数过多，直接返回false
        return false;
    }
    public boolean search(String searchWord) {
        return dfs(tree,searchWord,0,0);
    }
}
```





#### 最短的单词编码

> 题目来源：LeetCode 剑指 Offer II 065 
>
> 标签：前缀树、深度优先搜索DFS

单词数组 `words` 的 **有效编码** 由任意助记字符串 `s` 和下标数组 `indices` 组成，且满足：

- `words.length == indices.length`
- 助记字符串 `s` 以 `'#'` 字符结尾
- 对于每个下标 `indices[i]` ，`s` 的一个从 `indices[i]` 开始、到下一个 `'#'` 字符结束（但不包括 `'#'`）的 **子字符串** 恰好与 `words[i]` 相等

给定一个单词数组 `words` ，返回成功对 `words` 进行编码的最小助记字符串 `s` 的长度 。



```java
class Trie{
    public Trie [] children;
    public boolean isend;
    public int cnt; //当前结点有几个子节点
    Trie(){
        children = new Trie[26];
        isend = false;
        cnt = 0;
    }
    public void reverseinsert(String str){
        Trie node = this;
        for (int i = str.length()-1;i >= 0;i--){
            char ch = str.charAt(i);
            int idx = ch - 'a';
            if (node.children[idx] == null){
                node.children[idx] = new Trie();
                node.cnt += 1;
            }
            node = node.children[idx];
        }
        node.isend = true;
    }
}

class Solution {
    int ans = 0;
    public void dfs(Trie tree,int floor){
        if (tree.isend && tree.cnt == 0){
            ans += floor;
            return ;
        }
        for (int i = 0;i < 26;i++){
            if (tree.children[i] != null){
                dfs(tree.children[i],floor+1);
            }
        }
    }
    public int minimumLengthEncoding(String[] words) {
        Trie tree = new Trie();
        for (String word: words){
            tree.reverseinsert(word);
        }
        dfs(tree,1);
        return ans;
    }
}
```



#### 单词之和

> 题目来源：LeetCode 剑指 Offer II 066
>
> 标签：前缀树、深度优先搜索DFS

实现一个 `MapSum` 类，支持两个方法，`insert` 和 `sum`：

- `MapSum()` 初始化 `MapSum` 对象
- `void insert(String key, int val)` 插入 `key-val` 键值对，字符串表示键 `key` ，整数表示值 `val` 。如果键 `key` 已经存在，那么原来的键值对将被替代成新的键值对。
- `int sum(string prefix)` 返回所有以该前缀 `prefix` 开头的键 `key` 的值的总和。



```java
class Trie{
    public Trie [] children;
    public boolean isend;
    public int cnt;
    Trie(){
        children = new Trie[26];
        isend = false;
        cnt = 0;
    }
    public void insert(String str){
        Trie node = this;
        for (int i = 0;i < str.length();i++){
            char ch = str.charAt(i);
            int idx = ch - 'a';
            if (node.children[idx] == null){
                node.children[idx] = new Trie();
                node.cnt += 1;
            }
            node = node.children[idx];
        }
        node.isend = true;
    }

}
class MapSum {
    Trie tree;
    Map<String ,Integer> m;
    int ans = 0;
    StringBuilder sb;
    
    public MapSum() {
        tree = new Trie();
        m = new HashMap<>();
    }

    public void insert(String key, int val) {
        tree.insert(key);
        m.put(key,val);
    }
    public void dfs(Trie node){
        if (node == null) return;
        if (node.isend){
            ans += m.getOrDefault(sb.toString(),0);
        }
        if (node.cnt == 0) return;
        for (int i  = 0; i < 26;i++){
            if (node.children[i] == null) continue;
            sb.append((char)('a' + i));
            dfs(node.children[i]);
            sb.deleteCharAt(sb.length()-1);
        }
    }
    public int sum(String prefix) {
        Trie node = tree;
        for (int i = 0;i < prefix.length();i++){
            char ch = prefix.charAt(i);
            int idx = ch - 'a';
            if ((node.children[idx] == null) || (node.isend && node.cnt == 0)){
                return 0;
            }
            node = node.children[idx];
        }
        ans = 0;
        sb = new StringBuilder(prefix);
        dfs(node);
        return ans;
    }
}
```



#### 数组中两个数的最大异或值

> 题目来源：LeetCode 剑指 Offer II 067
>
> 标签：前缀树、位运算

给你一个整数数组 `nums` ，返回 `nums[i] XOR nums[j]` 的最大运算结果，其中 `0 ≤ i ≤ j < n` 。

**进阶：**你可以在 `O(n)` 的时间解决这个问题吗？

```java
class Trie{
    public Trie [] children;
    Trie(){
        children = new Trie[2];
    }
    public void insert(int num){
        Trie node = this;
        for (int i = 30;i >= 0;i--){
            int bit = (num >> i) & 1;
            if (node.children[bit] == null){
                node.children[bit] = new Trie();
            }
            node = node.children[bit];
        }
    }
    public int check(int num){
        Trie node = this;
        int val = 0;
        for (int i = 30;i >= 0;i--){
            int bit = (num >> i) & 1;
            if (bit == 1){
                if (node.children[0] != null){
                    val |= (1 << i);
                    node = node.children[0];
                }else{
                    node = node.children[1];
                }
            }else{
                if (node.children[1] != null){
                    val |= (1 << i);
                    node = node.children[1];
                }else{
                    node = node.children[0];
                }
            }
        }
        return val;
    }
}

public class Solution {
    public int findMaximumXOR(int[] nums) {
        int ans = 0;
        Trie tree = new Trie();
        for (int num:nums){
            tree.insert(num);
        }
        for (int num:nums){
            ans = Math.max(ans,tree.check(num));
        }
        return ans;
    }
}
```

