# 哈希算法

**特点:** 

- 不管原始数据有多长, 通过哈希算法进行计算, 得到的结果的**长度**是**固定**的
  - 是一个**二进制的字符串**
- 只要是原始数据不一样, 得到的结果就不一样
  - 原始数据差一丢丢, 得到的结果也是完全不同的
- 有很强的抗碰撞性
  - 碰撞: 原始数据不同, 但是通过同样的哈希算法进行计算能得到相同的结果
  - 推导的结论:
     - 数据不同得到的结果就不同
  - 应用场景:
     - 数据校验
        - 比如下载软件过程中防止加入恶意程序**[**对下载后的软件进行hash运算然后对比官方提供散列值是否相同**]**
      - 登录验证
          - 比如linux系统中存储的密码是经过hash算法加密过的
     - 秒传
        - 
- 不可逆
  - 得到的结果不能推导出原始数据

哈希运算的结果：散列值/指纹/摘要

## 消息认证码

作用: 

- 在通信的时候, 校验通信的数据有没有被篡改(完整性)
- 没有加密的功能

使用:

- 消息认证码的本质是一个散列值
- `(原始数据 + 秘钥) * 哈希函数 = 消息认证码`
  - 最关键的数据: 秘钥

校验的过程:

- 数据发送方A, 数据接收方B
- 在A或B端生成一个秘钥: X, 进行分发 -> A和B端都有了 秘钥: X
- 在A端进行散列值运算:  (原始数据 + x) * 哈希函数 = 得到散列值
- 在A端: 将原始数据和散列值同时发送给B
- 在B端:  -> AB端使用的哈希算法是相同的
  - 接收数据
  - 校验: (接收的原始数据 + x) * 哈希函数 = 散列值New
  - 比较散列值: 散列值New 和 接收的散列值 是不是相同
    - 相同: 没篡改
    - 不同: 被修改了

缺点:

- 秘钥分发困难
- 不能区分消息的所有者

## 数字签名

作用:

- 校验数据有没有被篡改(完整性)
- 鉴别数据的所有者
- 不能对数据加密

数字签名的过程:  -> 私钥加密数据

- 生成一个非对称加密的密钥对, 分发公钥
- 使用哈希函数对原始数据进行哈希运算 -> 散列值
- 使用私钥对散列值加密 -> 密文
- 将原始数据和密文一起发送给接收者

校验签名的过程:

- 接收签名的一方分发的公钥
- 接收签名者发送的数据:  `接收的原始数据 + 签名`  
- 对数据进行判断:
  - 对`接收的原始数据`进行哈希运算 -> 散列值new
    - 和签名的时候使用的哈希函数相同(必须相同)
  - 使用公钥对签名(密文) 解密 -> 得到了散列值old
  - 比较两个散列值
    - 相同: 数据的所有者确实是A 并且 数据没有被篡改
    - 不同:  数据的所有者不是A 或者 数据被篡改了